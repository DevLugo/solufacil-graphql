
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Log
 * 
 */
export type Log = {
  id: string
  requestBody: string
  requestType: string
  deviceType: string
  createdAt: Date
  updatedAt: Date
  systemSectionId: string
}

/**
 * Model SystemSection
 * 
 */
export type SystemSection = {
  id: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  /**
   * @FieldType({ name: 'Scalars.GraphQLEmailAddress', from: 'graphql-scalars', input: true })
   */
  email: string
  /**
   * @HideField({ output: false, input: true })
   */
  fullName: string
  firstName: string
  lastName: string
  password: string
  /**
   * @HideField({ output: false, input: true })
   */
  lastLogin: Date | null
  /**
   * @HideField({ output: false, input: true })
   */
  profilePicture: string | null
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
}

/**
 * Model Employee
 * 
 */
export type Employee = {
  /**
   * @HideField({ match: 'EmployeeCreate*Input' })
   */
  id: string
  type: EmployeesTypes
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  userId: string
}

/**
 * Model Document
 * 
 */
export type Document = {
  id: string
  type: DocumentType
  borrowerId: string | null
  avalId: string | null
  contractId: string | null
  employeeId: string | null
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  id: string
  name: string
  logo: string
  url: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Aval
 * 
 */
export type Aval = {
  /**
   * @HideField({ match: 'BorrowerCreate*Input' })
   */
  id: string
  /**
   * @FieldType({ name: 'Scalars.GraphQLEmailAddress', from: 'graphql-scalars', input: true })
   */
  email: string
  /**
   * @HideField({ output: false, input: true })
   */
  fullName: string
  firstName: string
  lastName: string
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
}

/**
 * Model Borrower
 * 
 */
export type Borrower = {
  /**
   * @HideField({ match: 'BorrowerCreate*Input' })
   */
  id: string
  name: string
  address: string
  /**
   * @FieldType({ name: 'Scalars.GraphQLEmailAddress', from: 'graphql-scalars', input: true })
   */
  email: string | null
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
}

/**
 * Model Local
 * 
 */
export type Local = {
  /**
   * @HideField({ match: 'LocalCreate*Input' })
   */
  id: string
  name: string
  address: string
  /**
   * @HideField({ output: false, input:true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  borrowerId: string
}

/**
 * Model Phone
 * 
 */
export type Phone = {
  /**
   * @HideField({ match: 'PhoneCreate*Input' })
   */
  id: string
  number: string
  /**
   * @HideField({ output: false, input: true })
   */
  borrowerId: string | null
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  /**
   * @showField()
   */
  avalId: string | null
  employeeId: string | null
}

/**
 * Model ContractType
 * 
 */
export type ContractType = {
  /**
   * @HideField({ output: false, input: true })
   */
  id: string
  /**
   * @Validator.MinLength(3)
   */
  name: string
  monthDuration: number
  amount: Prisma.Decimal
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date | null
}

/**
 * Model Loantype
 * 
 */
export type Loantype = {
  id: string
  name: string
  weekDuration: number
  rate: number
  overdueRate: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Contract
 * 
 */
export type Contract = {
  /**
   * @HideField({ match: 'ContractCreate*Input' })
   */
  id: string
  amount: Prisma.Decimal
  borrowerId: string
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  dueDate: Date
  signDate: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  employeeId: string
}

/**
 * Model Loan
 * 
 */
export type Loan = {
  /**
   * @HideField({ match: 'LoanCreateInput' })
   */
  id: string
  /**
   * @HideField({ output: false, input: true })
   */
  status: LoanState
  /**
   * @HideField({ match: 'LoanCreateInput' })
   */
  weeklyPaymentAmount: Prisma.Decimal
  amountToPay: Prisma.Decimal
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  contractId: string
  loantypeId: string
  employeeId: string
}

/**
 * Model LoanPayment
 * 
 */
export type LoanPayment = {
  id: string
  amount: Prisma.Decimal
  date: Date
  comments: string | null
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  loanId: string
  employeeId: string
}

/**
 * Model PaymentSchedule
 * 
 */
export type PaymentSchedule = {
  /**
   * @HideField({ match: 'PaymentScheduleCreate*Input' })
   */
  id: string
  numeration: number
  amountToPay: Prisma.Decimal
  paidAmount: Prisma.Decimal
  /**
   * @HideField({ output: false, input: true })
   */
  status: PaymentState
  delayed: boolean
  dueDate: Date
  details: string | null
  /**
   * @HideField({ output: false, input: true })
   */
  createdAt: Date
  /**
   * @HideField({ output: false, input: true })
   */
  updatedAt: Date
  loanId: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const EmployeesTypes: {
  EJECUTIVO_DE_ENLACE: 'EJECUTIVO_DE_ENLACE'
};

export type EmployeesTypes = (typeof EmployeesTypes)[keyof typeof EmployeesTypes]


export const DocumentType: {
  DNI: 'DNI',
  NSS: 'NSS',
  RFC: 'RFC',
  SHOP_PHOTO: 'SHOP_PHOTO',
  BANC_ACCOUNT: 'BANC_ACCOUNT',
  ADDRESS_PROFF: 'ADDRESS_PROFF',
  CREDIT_BUREAU: 'CREDIT_BUREAU',
  DRIVER_LICENCE: 'DRIVER_LICENCE',
  JOB_APPLICATION: 'JOB_APPLICATION',
  CONTRACT_EVIDENCE: 'CONTRACT_EVIDENCE',
  LETTER_NO_CRIMINAL_RECORD: 'LETTER_NO_CRIMINAL_RECORD'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const LoanState: {
  REQUESTED: 'REQUESTED',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PAID_OUT: 'PAID_OUT',
  POSTPONED: 'POSTPONED'
};

export type LoanState = (typeof LoanState)[keyof typeof LoanState]


export const PaymentState: {
  PENDING: 'PENDING',
  PAID_OUT: 'PAID_OUT',
  PARTIALLY_PAID: 'PARTIALLY_PAID'
};

export type PaymentState = (typeof PaymentState)[keyof typeof PaymentState]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Logs
 * const logs = await prisma.log.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Logs
   * const logs = await prisma.log.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<GlobalReject>;

  /**
   * `prisma.systemSection`: Exposes CRUD operations for the **SystemSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSections
    * const systemSections = await prisma.systemSection.findMany()
    * ```
    */
  get systemSection(): Prisma.SystemSectionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<GlobalReject>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.aval`: Exposes CRUD operations for the **Aval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avals
    * const avals = await prisma.aval.findMany()
    * ```
    */
  get aval(): Prisma.AvalDelegate<GlobalReject>;

  /**
   * `prisma.borrower`: Exposes CRUD operations for the **Borrower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borrowers
    * const borrowers = await prisma.borrower.findMany()
    * ```
    */
  get borrower(): Prisma.BorrowerDelegate<GlobalReject>;

  /**
   * `prisma.local`: Exposes CRUD operations for the **Local** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locals
    * const locals = await prisma.local.findMany()
    * ```
    */
  get local(): Prisma.LocalDelegate<GlobalReject>;

  /**
   * `prisma.phone`: Exposes CRUD operations for the **Phone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phones
    * const phones = await prisma.phone.findMany()
    * ```
    */
  get phone(): Prisma.PhoneDelegate<GlobalReject>;

  /**
   * `prisma.contractType`: Exposes CRUD operations for the **ContractType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractTypes
    * const contractTypes = await prisma.contractType.findMany()
    * ```
    */
  get contractType(): Prisma.ContractTypeDelegate<GlobalReject>;

  /**
   * `prisma.loantype`: Exposes CRUD operations for the **Loantype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loantypes
    * const loantypes = await prisma.loantype.findMany()
    * ```
    */
  get loantype(): Prisma.LoantypeDelegate<GlobalReject>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<GlobalReject>;

  /**
   * `prisma.loan`: Exposes CRUD operations for the **Loan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loan.findMany()
    * ```
    */
  get loan(): Prisma.LoanDelegate<GlobalReject>;

  /**
   * `prisma.loanPayment`: Exposes CRUD operations for the **LoanPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanPayments
    * const loanPayments = await prisma.loanPayment.findMany()
    * ```
    */
  get loanPayment(): Prisma.LoanPaymentDelegate<GlobalReject>;

  /**
   * `prisma.paymentSchedule`: Exposes CRUD operations for the **PaymentSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentSchedules
    * const paymentSchedules = await prisma.paymentSchedule.findMany()
    * ```
    */
  get paymentSchedule(): Prisma.PaymentScheduleDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.8.1
   * Query Engine version: 34df67547cf5598f5a6cd3eb45f14ee70c3fb86f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Log: 'Log',
    SystemSection: 'SystemSection',
    User: 'User',
    Employee: 'Employee',
    Document: 'Document',
    Customer: 'Customer',
    Aval: 'Aval',
    Borrower: 'Borrower',
    Local: 'Local',
    Phone: 'Phone',
    ContractType: 'ContractType',
    Loantype: 'Loantype',
    Contract: 'Contract',
    Loan: 'Loan',
    LoanPayment: 'LoanPayment',
    PaymentSchedule: 'PaymentSchedule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SystemSectionCountOutputType
   */


  export type SystemSectionCountOutputType = {
    logs: number
  }

  export type SystemSectionCountOutputTypeSelect = {
    logs?: boolean
  }

  export type SystemSectionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SystemSectionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SystemSectionCountOutputType
    : S extends undefined
    ? never
    : S extends SystemSectionCountOutputTypeArgs
    ?'include' extends U
    ? SystemSectionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SystemSectionCountOutputType ?SystemSectionCountOutputType [P]
  : 
     never
  } 
    : SystemSectionCountOutputType
  : SystemSectionCountOutputType




  // Custom InputTypes

  /**
   * SystemSectionCountOutputType without action
   */
  export type SystemSectionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SystemSectionCountOutputType
     * 
    **/
    select?: SystemSectionCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Employee: number
  }

  export type UserCountOutputTypeSelect = {
    Employee?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type EmployeeCountOutputType
   */


  export type EmployeeCountOutputType = {
    phones: number
    documents: number
    contracts: number
    loan: number
    loanPayment: number
  }

  export type EmployeeCountOutputTypeSelect = {
    phones?: boolean
    documents?: boolean
    contracts?: boolean
    loan?: boolean
    loanPayment?: boolean
  }

  export type EmployeeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmployeeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmployeeCountOutputType
    : S extends undefined
    ? never
    : S extends EmployeeCountOutputTypeArgs
    ?'include' extends U
    ? EmployeeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof EmployeeCountOutputType ?EmployeeCountOutputType [P]
  : 
     never
  } 
    : EmployeeCountOutputType
  : EmployeeCountOutputType




  // Custom InputTypes

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     * 
    **/
    select?: EmployeeCountOutputTypeSelect | null
  }



  /**
   * Count Type AvalCountOutputType
   */


  export type AvalCountOutputType = {
    phones: number
    documents: number
  }

  export type AvalCountOutputTypeSelect = {
    phones?: boolean
    documents?: boolean
  }

  export type AvalCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AvalCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AvalCountOutputType
    : S extends undefined
    ? never
    : S extends AvalCountOutputTypeArgs
    ?'include' extends U
    ? AvalCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AvalCountOutputType ?AvalCountOutputType [P]
  : 
     never
  } 
    : AvalCountOutputType
  : AvalCountOutputType




  // Custom InputTypes

  /**
   * AvalCountOutputType without action
   */
  export type AvalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AvalCountOutputType
     * 
    **/
    select?: AvalCountOutputTypeSelect | null
  }



  /**
   * Count Type BorrowerCountOutputType
   */


  export type BorrowerCountOutputType = {
    phones: number
    documents: number
    Contract: number
    Local: number
  }

  export type BorrowerCountOutputTypeSelect = {
    phones?: boolean
    documents?: boolean
    Contract?: boolean
    Local?: boolean
  }

  export type BorrowerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BorrowerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BorrowerCountOutputType
    : S extends undefined
    ? never
    : S extends BorrowerCountOutputTypeArgs
    ?'include' extends U
    ? BorrowerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BorrowerCountOutputType ?BorrowerCountOutputType [P]
  : 
     never
  } 
    : BorrowerCountOutputType
  : BorrowerCountOutputType




  // Custom InputTypes

  /**
   * BorrowerCountOutputType without action
   */
  export type BorrowerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BorrowerCountOutputType
     * 
    **/
    select?: BorrowerCountOutputTypeSelect | null
  }



  /**
   * Count Type LoantypeCountOutputType
   */


  export type LoantypeCountOutputType = {
    Loan: number
  }

  export type LoantypeCountOutputTypeSelect = {
    Loan?: boolean
  }

  export type LoantypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LoantypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LoantypeCountOutputType
    : S extends undefined
    ? never
    : S extends LoantypeCountOutputTypeArgs
    ?'include' extends U
    ? LoantypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LoantypeCountOutputType ?LoantypeCountOutputType [P]
  : 
     never
  } 
    : LoantypeCountOutputType
  : LoantypeCountOutputType




  // Custom InputTypes

  /**
   * LoantypeCountOutputType without action
   */
  export type LoantypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LoantypeCountOutputType
     * 
    **/
    select?: LoantypeCountOutputTypeSelect | null
  }



  /**
   * Count Type ContractCountOutputType
   */


  export type ContractCountOutputType = {
    documents: number
    loans: number
  }

  export type ContractCountOutputTypeSelect = {
    documents?: boolean
    loans?: boolean
  }

  export type ContractCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ContractCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ContractCountOutputType
    : S extends undefined
    ? never
    : S extends ContractCountOutputTypeArgs
    ?'include' extends U
    ? ContractCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ContractCountOutputType ?ContractCountOutputType [P]
  : 
     never
  } 
    : ContractCountOutputType
  : ContractCountOutputType




  // Custom InputTypes

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     * 
    **/
    select?: ContractCountOutputTypeSelect | null
  }



  /**
   * Count Type LoanCountOutputType
   */


  export type LoanCountOutputType = {
    payments: number
    paymentSchedule: number
  }

  export type LoanCountOutputTypeSelect = {
    payments?: boolean
    paymentSchedule?: boolean
  }

  export type LoanCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LoanCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LoanCountOutputType
    : S extends undefined
    ? never
    : S extends LoanCountOutputTypeArgs
    ?'include' extends U
    ? LoanCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LoanCountOutputType ?LoanCountOutputType [P]
  : 
     never
  } 
    : LoanCountOutputType
  : LoanCountOutputType




  // Custom InputTypes

  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LoanCountOutputType
     * 
    **/
    select?: LoanCountOutputTypeSelect | null
  }



  /**
   * Count Type LoanPaymentCountOutputType
   */


  export type LoanPaymentCountOutputType = {
    paymentSchedules: number
  }

  export type LoanPaymentCountOutputTypeSelect = {
    paymentSchedules?: boolean
  }

  export type LoanPaymentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LoanPaymentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LoanPaymentCountOutputType
    : S extends undefined
    ? never
    : S extends LoanPaymentCountOutputTypeArgs
    ?'include' extends U
    ? LoanPaymentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LoanPaymentCountOutputType ?LoanPaymentCountOutputType [P]
  : 
     never
  } 
    : LoanPaymentCountOutputType
  : LoanPaymentCountOutputType




  // Custom InputTypes

  /**
   * LoanPaymentCountOutputType without action
   */
  export type LoanPaymentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LoanPaymentCountOutputType
     * 
    **/
    select?: LoanPaymentCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentScheduleCountOutputType
   */


  export type PaymentScheduleCountOutputType = {
    loanPayments: number
  }

  export type PaymentScheduleCountOutputTypeSelect = {
    loanPayments?: boolean
  }

  export type PaymentScheduleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PaymentScheduleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PaymentScheduleCountOutputType
    : S extends undefined
    ? never
    : S extends PaymentScheduleCountOutputTypeArgs
    ?'include' extends U
    ? PaymentScheduleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PaymentScheduleCountOutputType ?PaymentScheduleCountOutputType [P]
  : 
     never
  } 
    : PaymentScheduleCountOutputType
  : PaymentScheduleCountOutputType




  // Custom InputTypes

  /**
   * PaymentScheduleCountOutputType without action
   */
  export type PaymentScheduleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentScheduleCountOutputType
     * 
    **/
    select?: PaymentScheduleCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Log
   */


  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    requestBody: string | null
    requestType: string | null
    deviceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    systemSectionId: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    requestBody: string | null
    requestType: string | null
    deviceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    systemSectionId: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    requestBody: number
    requestType: number
    deviceType: number
    createdAt: number
    updatedAt: number
    systemSectionId: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    requestBody?: true
    requestType?: true
    deviceType?: true
    createdAt?: true
    updatedAt?: true
    systemSectionId?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    requestBody?: true
    requestType?: true
    deviceType?: true
    createdAt?: true
    updatedAt?: true
    systemSectionId?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    requestBody?: true
    requestType?: true
    deviceType?: true
    createdAt?: true
    updatedAt?: true
    systemSectionId?: true
    _all?: true
  }

  export type LogAggregateArgs = {
    /**
     * Filter which Log to aggregate.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs = {
    where?: LogWhereInput
    orderBy?: Enumerable<LogOrderByWithAggregationInput>
    by: Array<LogScalarFieldEnum>
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }


  export type LogGroupByOutputType = {
    id: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt: Date
    updatedAt: Date
    systemSectionId: string
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Promise<
    Array<
      PickArray<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect = {
    id?: boolean
    section?: boolean | SystemSectionArgs
    requestBody?: boolean
    requestType?: boolean
    deviceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemSectionId?: boolean
  }

  export type LogInclude = {
    section?: boolean | SystemSectionArgs
  }

  export type LogGetPayload<
    S extends boolean | null | undefined | LogArgs,
    U = keyof S
      > = S extends true
        ? Log
    : S extends undefined
    ? never
    : S extends LogArgs | LogFindManyArgs
    ?'include' extends U
    ? Log  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'section'
        ? SystemSectionGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Log ?Log [P]
  : 
          P extends 'section'
        ? SystemSectionGetPayload<S['select'][P]> : never
  } 
    : Log
  : Log


  type LogCountArgs = Merge<
    Omit<LogFindManyArgs, 'select' | 'include'> & {
      select?: LogCountAggregateInputType | true
    }
  >

  export interface LogDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null >, Prisma__LogClient<LogGetPayload<T> | null >>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null >, Prisma__LogClient<LogGetPayload<T> | null >>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFindManyArgs>(
      args?: SelectSubset<T, LogFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Log>>, PrismaPromise<Array<LogGetPayload<T>>>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends LogCreateArgs>(
      args: SelectSubset<T, LogCreateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Create many Logs.
     *     @param {LogCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const log = await prisma.log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogCreateManyArgs>(
      args?: SelectSubset<T, LogCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends LogDeleteArgs>(
      args: SelectSubset<T, LogDeleteArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogUpdateArgs>(
      args: SelectSubset<T, LogUpdateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogDeleteManyArgs>(
      args?: SelectSubset<T, LogDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogUpdateManyArgs>(
      args: SelectSubset<T, LogUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends LogUpsertArgs>(
      args: SelectSubset<T, LogUpsertArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    section<T extends SystemSectionArgs = {}>(args?: Subset<T, SystemSectionArgs>): CheckSelect<T, Prisma__SystemSectionClient<SystemSection | null >, Prisma__SystemSectionClient<SystemSectionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Throw an Error if a Log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Log to fetch.
     * 
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log findFirst
   */
  export type LogFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Throw an Error if a Log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Log to fetch.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     * 
    **/
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * Log findMany
   */
  export type LogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * Log create
   */
  export type LogCreateArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The data needed to create a Log.
     * 
    **/
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }


  /**
   * Log createMany
   */
  export type LogCreateManyArgs = {
    data: Enumerable<LogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Log update
   */
  export type LogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The data needed to update a Log.
     * 
    **/
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     * 
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs = {
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    where?: LogWhereInput
  }


  /**
   * Log upsert
   */
  export type LogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The filter to search for the Log to update in case it exists.
     * 
    **/
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     * 
    **/
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }


  /**
   * Log delete
   */
  export type LogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter which Log to delete.
     * 
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs = {
    where?: LogWhereInput
  }


  /**
   * Log without action
   */
  export type LogArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
  }



  /**
   * Model SystemSection
   */


  export type AggregateSystemSection = {
    _count: SystemSectionCountAggregateOutputType | null
    _min: SystemSectionMinAggregateOutputType | null
    _max: SystemSectionMaxAggregateOutputType | null
  }

  export type SystemSectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSectionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSectionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSectionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSectionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSectionAggregateArgs = {
    /**
     * Filter which SystemSection to aggregate.
     * 
    **/
    where?: SystemSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSections to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SystemSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSections
    **/
    _count?: true | SystemSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSectionMaxAggregateInputType
  }

  export type GetSystemSectionAggregateType<T extends SystemSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSection[P]>
      : GetScalarType<T[P], AggregateSystemSection[P]>
  }




  export type SystemSectionGroupByArgs = {
    where?: SystemSectionWhereInput
    orderBy?: Enumerable<SystemSectionOrderByWithAggregationInput>
    by: Array<SystemSectionScalarFieldEnum>
    having?: SystemSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSectionCountAggregateInputType | true
    _min?: SystemSectionMinAggregateInputType
    _max?: SystemSectionMaxAggregateInputType
  }


  export type SystemSectionGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SystemSectionCountAggregateOutputType | null
    _min: SystemSectionMinAggregateOutputType | null
    _max: SystemSectionMaxAggregateOutputType | null
  }

  type GetSystemSectionGroupByPayload<T extends SystemSectionGroupByArgs> = Promise<
    Array<
      PickArray<SystemSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSectionGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSectionGroupByOutputType[P]>
        }
      >
    >


  export type SystemSectionSelect = {
    id?: boolean
    name?: boolean
    logs?: boolean | LogFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SystemSectionCountOutputTypeArgs
  }

  export type SystemSectionInclude = {
    logs?: boolean | LogFindManyArgs
    _count?: boolean | SystemSectionCountOutputTypeArgs
  }

  export type SystemSectionGetPayload<
    S extends boolean | null | undefined | SystemSectionArgs,
    U = keyof S
      > = S extends true
        ? SystemSection
    : S extends undefined
    ? never
    : S extends SystemSectionArgs | SystemSectionFindManyArgs
    ?'include' extends U
    ? SystemSection  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'logs'
        ? Array < LogGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SystemSectionCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SystemSection ?SystemSection [P]
  : 
          P extends 'logs'
        ? Array < LogGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SystemSectionCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : SystemSection
  : SystemSection


  type SystemSectionCountArgs = Merge<
    Omit<SystemSectionFindManyArgs, 'select' | 'include'> & {
      select?: SystemSectionCountAggregateInputType | true
    }
  >

  export interface SystemSectionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SystemSection that matches the filter.
     * @param {SystemSectionFindUniqueArgs} args - Arguments to find a SystemSection
     * @example
     * // Get one SystemSection
     * const systemSection = await prisma.systemSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SystemSectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SystemSectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SystemSection'> extends True ? CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>> : CheckSelect<T, Prisma__SystemSectionClient<SystemSection | null >, Prisma__SystemSectionClient<SystemSectionGetPayload<T> | null >>

    /**
     * Find the first SystemSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionFindFirstArgs} args - Arguments to find a SystemSection
     * @example
     * // Get one SystemSection
     * const systemSection = await prisma.systemSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SystemSectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SystemSectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SystemSection'> extends True ? CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>> : CheckSelect<T, Prisma__SystemSectionClient<SystemSection | null >, Prisma__SystemSectionClient<SystemSectionGetPayload<T> | null >>

    /**
     * Find zero or more SystemSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSections
     * const systemSections = await prisma.systemSection.findMany()
     * 
     * // Get first 10 SystemSections
     * const systemSections = await prisma.systemSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSectionWithIdOnly = await prisma.systemSection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SystemSectionFindManyArgs>(
      args?: SelectSubset<T, SystemSectionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SystemSection>>, PrismaPromise<Array<SystemSectionGetPayload<T>>>>

    /**
     * Create a SystemSection.
     * @param {SystemSectionCreateArgs} args - Arguments to create a SystemSection.
     * @example
     * // Create one SystemSection
     * const SystemSection = await prisma.systemSection.create({
     *   data: {
     *     // ... data to create a SystemSection
     *   }
     * })
     * 
    **/
    create<T extends SystemSectionCreateArgs>(
      args: SelectSubset<T, SystemSectionCreateArgs>
    ): CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>>

    /**
     * Create many SystemSections.
     *     @param {SystemSectionCreateManyArgs} args - Arguments to create many SystemSections.
     *     @example
     *     // Create many SystemSections
     *     const systemSection = await prisma.systemSection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SystemSectionCreateManyArgs>(
      args?: SelectSubset<T, SystemSectionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSection.
     * @param {SystemSectionDeleteArgs} args - Arguments to delete one SystemSection.
     * @example
     * // Delete one SystemSection
     * const SystemSection = await prisma.systemSection.delete({
     *   where: {
     *     // ... filter to delete one SystemSection
     *   }
     * })
     * 
    **/
    delete<T extends SystemSectionDeleteArgs>(
      args: SelectSubset<T, SystemSectionDeleteArgs>
    ): CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>>

    /**
     * Update one SystemSection.
     * @param {SystemSectionUpdateArgs} args - Arguments to update one SystemSection.
     * @example
     * // Update one SystemSection
     * const systemSection = await prisma.systemSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SystemSectionUpdateArgs>(
      args: SelectSubset<T, SystemSectionUpdateArgs>
    ): CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>>

    /**
     * Delete zero or more SystemSections.
     * @param {SystemSectionDeleteManyArgs} args - Arguments to filter SystemSections to delete.
     * @example
     * // Delete a few SystemSections
     * const { count } = await prisma.systemSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SystemSectionDeleteManyArgs>(
      args?: SelectSubset<T, SystemSectionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSections
     * const systemSection = await prisma.systemSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SystemSectionUpdateManyArgs>(
      args: SelectSubset<T, SystemSectionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSection.
     * @param {SystemSectionUpsertArgs} args - Arguments to update or create a SystemSection.
     * @example
     * // Update or create a SystemSection
     * const systemSection = await prisma.systemSection.upsert({
     *   create: {
     *     // ... data to create a SystemSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSection we want to update
     *   }
     * })
    **/
    upsert<T extends SystemSectionUpsertArgs>(
      args: SelectSubset<T, SystemSectionUpsertArgs>
    ): CheckSelect<T, Prisma__SystemSectionClient<SystemSection>, Prisma__SystemSectionClient<SystemSectionGetPayload<T>>>

    /**
     * Count the number of SystemSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionCountArgs} args - Arguments to filter SystemSections to count.
     * @example
     * // Count the number of SystemSections
     * const count = await prisma.systemSection.count({
     *   where: {
     *     // ... the filter for the SystemSections we want to count
     *   }
     * })
    **/
    count<T extends SystemSectionCountArgs>(
      args?: Subset<T, SystemSectionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSectionAggregateArgs>(args: Subset<T, SystemSectionAggregateArgs>): PrismaPromise<GetSystemSectionAggregateType<T>>

    /**
     * Group by SystemSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSectionGroupByArgs['orderBy'] }
        : { orderBy?: SystemSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSectionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SystemSectionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    logs<T extends LogFindManyArgs = {}>(args?: Subset<T, LogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Log>>, PrismaPromise<Array<LogGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SystemSection findUnique
   */
  export type SystemSectionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * Throw an Error if a SystemSection can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SystemSection to fetch.
     * 
    **/
    where: SystemSectionWhereUniqueInput
  }


  /**
   * SystemSection findFirst
   */
  export type SystemSectionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * Throw an Error if a SystemSection can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SystemSection to fetch.
     * 
    **/
    where?: SystemSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSections to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSections.
     * 
    **/
    cursor?: SystemSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSections.
     * 
    **/
    distinct?: Enumerable<SystemSectionScalarFieldEnum>
  }


  /**
   * SystemSection findMany
   */
  export type SystemSectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * Filter, which SystemSections to fetch.
     * 
    **/
    where?: SystemSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSections to fetch.
     * 
    **/
    orderBy?: Enumerable<SystemSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSections.
     * 
    **/
    cursor?: SystemSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SystemSectionScalarFieldEnum>
  }


  /**
   * SystemSection create
   */
  export type SystemSectionCreateArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * The data needed to create a SystemSection.
     * 
    **/
    data: XOR<SystemSectionCreateInput, SystemSectionUncheckedCreateInput>
  }


  /**
   * SystemSection createMany
   */
  export type SystemSectionCreateManyArgs = {
    data: Enumerable<SystemSectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SystemSection update
   */
  export type SystemSectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * The data needed to update a SystemSection.
     * 
    **/
    data: XOR<SystemSectionUpdateInput, SystemSectionUncheckedUpdateInput>
    /**
     * Choose, which SystemSection to update.
     * 
    **/
    where: SystemSectionWhereUniqueInput
  }


  /**
   * SystemSection updateMany
   */
  export type SystemSectionUpdateManyArgs = {
    data: XOR<SystemSectionUpdateManyMutationInput, SystemSectionUncheckedUpdateManyInput>
    where?: SystemSectionWhereInput
  }


  /**
   * SystemSection upsert
   */
  export type SystemSectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * The filter to search for the SystemSection to update in case it exists.
     * 
    **/
    where: SystemSectionWhereUniqueInput
    /**
     * In case the SystemSection found by the `where` argument doesn't exist, create a new SystemSection with this data.
     * 
    **/
    create: XOR<SystemSectionCreateInput, SystemSectionUncheckedCreateInput>
    /**
     * In case the SystemSection was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SystemSectionUpdateInput, SystemSectionUncheckedUpdateInput>
  }


  /**
   * SystemSection delete
   */
  export type SystemSectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
    /**
     * Filter which SystemSection to delete.
     * 
    **/
    where: SystemSectionWhereUniqueInput
  }


  /**
   * SystemSection deleteMany
   */
  export type SystemSectionDeleteManyArgs = {
    where?: SystemSectionWhereInput
  }


  /**
   * SystemSection without action
   */
  export type SystemSectionArgs = {
    /**
     * Select specific fields to fetch from the SystemSection
     * 
    **/
    select?: SystemSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SystemSectionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    lastLogin: Date | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    lastLogin: Date | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    firstName: number
    lastName: number
    password: number
    lastLogin: number
    profilePicture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    password?: true
    lastLogin?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    password?: true
    lastLogin?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    password?: true
    lastLogin?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin: Date | null
    profilePicture: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    lastLogin?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    Employee?: boolean | EmployeeFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Employee'
        ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'Employee'
        ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Employee<T extends EmployeeFindManyArgs = {}>(args?: Subset<T, EmployeeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Employee
   */


  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    type: EmployeesTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    type: EmployeesTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs = {
    /**
     * Filter which Employee to aggregate.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs = {
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByWithAggregationInput>
    by: Array<EmployeeScalarFieldEnum>
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }


  export type EmployeeGroupByOutputType = {
    id: string
    type: EmployeesTypes
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Promise<
    Array<
      PickArray<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect = {
    id?: boolean
    type?: boolean
    phones?: boolean | PhoneFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
    contracts?: boolean | ContractFindManyArgs
    loan?: boolean | LoanFindManyArgs
    userId?: boolean
    loanPayment?: boolean | LoanPaymentFindManyArgs
    _count?: boolean | EmployeeCountOutputTypeArgs
  }

  export type EmployeeInclude = {
    phones?: boolean | PhoneFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    user?: boolean | UserArgs
    contracts?: boolean | ContractFindManyArgs
    loan?: boolean | LoanFindManyArgs
    loanPayment?: boolean | LoanPaymentFindManyArgs
    _count?: boolean | EmployeeCountOutputTypeArgs
  }

  export type EmployeeGetPayload<
    S extends boolean | null | undefined | EmployeeArgs,
    U = keyof S
      > = S extends true
        ? Employee
    : S extends undefined
    ? never
    : S extends EmployeeArgs | EmployeeFindManyArgs
    ?'include' extends U
    ? Employee  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['include'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['include'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'contracts'
        ? Array < ContractGetPayload<S['include'][P]>>  :
        P extends 'loan'
        ? Array < LoanGetPayload<S['include'][P]>>  :
        P extends 'loanPayment'
        ? Array < LoanPaymentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? EmployeeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Employee ?Employee [P]
  : 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['select'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['select'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'contracts'
        ? Array < ContractGetPayload<S['select'][P]>>  :
        P extends 'loan'
        ? Array < LoanGetPayload<S['select'][P]>>  :
        P extends 'loanPayment'
        ? Array < LoanPaymentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? EmployeeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Employee
  : Employee


  type EmployeeCountArgs = Merge<
    Omit<EmployeeFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeCountAggregateInputType | true
    }
  >

  export interface EmployeeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmployeeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmployeeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeFindManyArgs>(
      args?: SelectSubset<T, EmployeeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
    **/
    create<T extends EmployeeCreateArgs>(
      args: SelectSubset<T, EmployeeCreateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Create many Employees.
     *     @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     *     @example
     *     // Create many Employees
     *     const employee = await prisma.employee.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeCreateManyArgs>(
      args?: SelectSubset<T, EmployeeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeDeleteArgs>(
      args: SelectSubset<T, EmployeeDeleteArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeUpdateArgs>(
      args: SelectSubset<T, EmployeeUpdateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeDeleteManyArgs>(
      args?: SelectSubset<T, EmployeeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeUpdateManyArgs>(
      args: SelectSubset<T, EmployeeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeUpsertArgs>(
      args: SelectSubset<T, EmployeeUpsertArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    phones<T extends PhoneFindManyArgs = {}>(args?: Subset<T, PhoneFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Phone>>, PrismaPromise<Array<PhoneGetPayload<T>>>>;

    documents<T extends DocumentFindManyArgs = {}>(args?: Subset<T, DocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    contracts<T extends ContractFindManyArgs = {}>(args?: Subset<T, ContractFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Contract>>, PrismaPromise<Array<ContractGetPayload<T>>>>;

    loan<T extends LoanFindManyArgs = {}>(args?: Subset<T, LoanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loan>>, PrismaPromise<Array<LoanGetPayload<T>>>>;

    loanPayment<T extends LoanPaymentFindManyArgs = {}>(args?: Subset<T, LoanPaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LoanPayment>>, PrismaPromise<Array<LoanPaymentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     * 
    **/
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter, which Employees to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee create
   */
  export type EmployeeCreateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to create a Employee.
     * 
    **/
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }


  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs = {
    data: Enumerable<EmployeeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Employee update
   */
  export type EmployeeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to update a Employee.
     * 
    **/
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs = {
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    where?: EmployeeWhereInput
  }


  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The filter to search for the Employee to update in case it exists.
     * 
    **/
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     * 
    **/
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }


  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter which Employee to delete.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs = {
    where?: EmployeeWhereInput
  }


  /**
   * Employee without action
   */
  export type EmployeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    type: DocumentType | null
    borrowerId: string | null
    avalId: string | null
    contractId: string | null
    employeeId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    type: DocumentType | null
    borrowerId: string | null
    avalId: string | null
    contractId: string | null
    employeeId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    type: number
    borrowerId: number
    avalId: number
    contractId: number
    employeeId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    type?: true
    borrowerId?: true
    avalId?: true
    contractId?: true
    employeeId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    type?: true
    borrowerId?: true
    avalId?: true
    contractId?: true
    employeeId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    type?: true
    borrowerId?: true
    avalId?: true
    contractId?: true
    employeeId?: true
    _all?: true
  }

  export type DocumentAggregateArgs = {
    /**
     * Filter which Document to aggregate.
     * 
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: Array<DocumentScalarFieldEnum>
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    type: DocumentType
    borrowerId: string | null
    avalId: string | null
    contractId: string | null
    employeeId: string | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Promise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect = {
    id?: boolean
    type?: boolean
    Borrower?: boolean | BorrowerArgs
    borrowerId?: boolean
    Employee?: boolean | EmployeeArgs
    aval?: boolean | AvalArgs
    avalId?: boolean
    Contract?: boolean | ContractArgs
    contractId?: boolean
    employeeId?: boolean
  }

  export type DocumentInclude = {
    Borrower?: boolean | BorrowerArgs
    Employee?: boolean | EmployeeArgs
    aval?: boolean | AvalArgs
    Contract?: boolean | ContractArgs
  }

  export type DocumentGetPayload<
    S extends boolean | null | undefined | DocumentArgs,
    U = keyof S
      > = S extends true
        ? Document
    : S extends undefined
    ? never
    : S extends DocumentArgs | DocumentFindManyArgs
    ?'include' extends U
    ? Document  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Borrower'
        ? BorrowerGetPayload<S['include'][P]> | null :
        P extends 'Employee'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'aval'
        ? AvalGetPayload<S['include'][P]> | null :
        P extends 'Contract'
        ? ContractGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Document ?Document [P]
  : 
          P extends 'Borrower'
        ? BorrowerGetPayload<S['select'][P]> | null :
        P extends 'Employee'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'aval'
        ? AvalGetPayload<S['select'][P]> | null :
        P extends 'Contract'
        ? ContractGetPayload<S['select'][P]> | null : never
  } 
    : Document
  : Document


  type DocumentCountArgs = Merge<
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }
  >

  export interface DocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>> : CheckSelect<T, Prisma__DocumentClient<Document | null >, Prisma__DocumentClient<DocumentGetPayload<T> | null >>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>> : CheckSelect<T, Prisma__DocumentClient<Document | null >, Prisma__DocumentClient<DocumentGetPayload<T> | null >>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Borrower<T extends BorrowerArgs = {}>(args?: Subset<T, BorrowerArgs>): CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>;

    Employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    aval<T extends AvalArgs = {}>(args?: Subset<T, AvalArgs>): CheckSelect<T, Prisma__AvalClient<Aval | null >, Prisma__AvalClient<AvalGetPayload<T> | null >>;

    Contract<T extends ContractArgs = {}>(args?: Subset<T, ContractArgs>): CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * Throw an Error if a Document can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Document to fetch.
     * 
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * Throw an Error if a Document can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Document to fetch.
     * 
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     * 
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     * 
    **/
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * Filter, which Documents to fetch.
     * 
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     * 
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * The data needed to create a Document.
     * 
    **/
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs = {
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * The data needed to update a Document.
     * 
    **/
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     * 
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs = {
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * The filter to search for the Document to update in case it exists.
     * 
    **/
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     * 
    **/
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
    /**
     * Filter which Document to delete.
     * 
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs = {
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs = {
    /**
     * Select specific fields to fetch from the Document
     * 
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DocumentInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: Array<CustomerScalarFieldEnum>
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: string
    name: string
    logo: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Promise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    name?: boolean
    logo?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerArgs,
    U = keyof S
      > = S extends true
        ? Customer
    : S extends undefined
    ? never
    : S extends CustomerArgs | CustomerFindManyArgs
    ?'include' extends U
    ? Customer 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Customer ?Customer [P]
  : 
     never
  } 
    : Customer
  : Customer


  type CustomerCountArgs = Merge<
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }
  >

  export interface CustomerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Throw an Error if a Customer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Throw an Error if a Customer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * The data needed to create a Customer.
     * 
    **/
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * The data needed to update a Customer.
     * 
    **/
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * The filter to search for the Customer to update in case it exists.
     * 
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     * 
    **/
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Filter which Customer to delete.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    where?: CustomerWhereInput
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
  }



  /**
   * Model Aval
   */


  export type AggregateAval = {
    _count: AvalCountAggregateOutputType | null
    _min: AvalMinAggregateOutputType | null
    _max: AvalMaxAggregateOutputType | null
  }

  export type AvalMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvalMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvalCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvalMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvalMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvalCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvalAggregateArgs = {
    /**
     * Filter which Aval to aggregate.
     * 
    **/
    where?: AvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avals to fetch.
     * 
    **/
    orderBy?: Enumerable<AvalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avals
    **/
    _count?: true | AvalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvalMaxAggregateInputType
  }

  export type GetAvalAggregateType<T extends AvalAggregateArgs> = {
        [P in keyof T & keyof AggregateAval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAval[P]>
      : GetScalarType<T[P], AggregateAval[P]>
  }




  export type AvalGroupByArgs = {
    where?: AvalWhereInput
    orderBy?: Enumerable<AvalOrderByWithAggregationInput>
    by: Array<AvalScalarFieldEnum>
    having?: AvalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvalCountAggregateInputType | true
    _min?: AvalMinAggregateInputType
    _max?: AvalMaxAggregateInputType
  }


  export type AvalGroupByOutputType = {
    id: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt: Date
    updatedAt: Date
    _count: AvalCountAggregateOutputType | null
    _min: AvalMinAggregateOutputType | null
    _max: AvalMaxAggregateOutputType | null
  }

  type GetAvalGroupByPayload<T extends AvalGroupByArgs> = Promise<
    Array<
      PickArray<AvalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvalGroupByOutputType[P]>
            : GetScalarType<T[P], AvalGroupByOutputType[P]>
        }
      >
    >


  export type AvalSelect = {
    id?: boolean
    phones?: boolean | PhoneFindManyArgs
    email?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    documents?: boolean | DocumentFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | AvalCountOutputTypeArgs
  }

  export type AvalInclude = {
    phones?: boolean | PhoneFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    _count?: boolean | AvalCountOutputTypeArgs
  }

  export type AvalGetPayload<
    S extends boolean | null | undefined | AvalArgs,
    U = keyof S
      > = S extends true
        ? Aval
    : S extends undefined
    ? never
    : S extends AvalArgs | AvalFindManyArgs
    ?'include' extends U
    ? Aval  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['include'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? AvalCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Aval ?Aval [P]
  : 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['select'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? AvalCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Aval
  : Aval


  type AvalCountArgs = Merge<
    Omit<AvalFindManyArgs, 'select' | 'include'> & {
      select?: AvalCountAggregateInputType | true
    }
  >

  export interface AvalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Aval that matches the filter.
     * @param {AvalFindUniqueArgs} args - Arguments to find a Aval
     * @example
     * // Get one Aval
     * const aval = await prisma.aval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AvalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AvalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Aval'> extends True ? CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>> : CheckSelect<T, Prisma__AvalClient<Aval | null >, Prisma__AvalClient<AvalGetPayload<T> | null >>

    /**
     * Find the first Aval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalFindFirstArgs} args - Arguments to find a Aval
     * @example
     * // Get one Aval
     * const aval = await prisma.aval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AvalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AvalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Aval'> extends True ? CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>> : CheckSelect<T, Prisma__AvalClient<Aval | null >, Prisma__AvalClient<AvalGetPayload<T> | null >>

    /**
     * Find zero or more Avals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avals
     * const avals = await prisma.aval.findMany()
     * 
     * // Get first 10 Avals
     * const avals = await prisma.aval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avalWithIdOnly = await prisma.aval.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AvalFindManyArgs>(
      args?: SelectSubset<T, AvalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Aval>>, PrismaPromise<Array<AvalGetPayload<T>>>>

    /**
     * Create a Aval.
     * @param {AvalCreateArgs} args - Arguments to create a Aval.
     * @example
     * // Create one Aval
     * const Aval = await prisma.aval.create({
     *   data: {
     *     // ... data to create a Aval
     *   }
     * })
     * 
    **/
    create<T extends AvalCreateArgs>(
      args: SelectSubset<T, AvalCreateArgs>
    ): CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>>

    /**
     * Create many Avals.
     *     @param {AvalCreateManyArgs} args - Arguments to create many Avals.
     *     @example
     *     // Create many Avals
     *     const aval = await prisma.aval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AvalCreateManyArgs>(
      args?: SelectSubset<T, AvalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Aval.
     * @param {AvalDeleteArgs} args - Arguments to delete one Aval.
     * @example
     * // Delete one Aval
     * const Aval = await prisma.aval.delete({
     *   where: {
     *     // ... filter to delete one Aval
     *   }
     * })
     * 
    **/
    delete<T extends AvalDeleteArgs>(
      args: SelectSubset<T, AvalDeleteArgs>
    ): CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>>

    /**
     * Update one Aval.
     * @param {AvalUpdateArgs} args - Arguments to update one Aval.
     * @example
     * // Update one Aval
     * const aval = await prisma.aval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AvalUpdateArgs>(
      args: SelectSubset<T, AvalUpdateArgs>
    ): CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>>

    /**
     * Delete zero or more Avals.
     * @param {AvalDeleteManyArgs} args - Arguments to filter Avals to delete.
     * @example
     * // Delete a few Avals
     * const { count } = await prisma.aval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AvalDeleteManyArgs>(
      args?: SelectSubset<T, AvalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avals
     * const aval = await prisma.aval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AvalUpdateManyArgs>(
      args: SelectSubset<T, AvalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Aval.
     * @param {AvalUpsertArgs} args - Arguments to update or create a Aval.
     * @example
     * // Update or create a Aval
     * const aval = await prisma.aval.upsert({
     *   create: {
     *     // ... data to create a Aval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aval we want to update
     *   }
     * })
    **/
    upsert<T extends AvalUpsertArgs>(
      args: SelectSubset<T, AvalUpsertArgs>
    ): CheckSelect<T, Prisma__AvalClient<Aval>, Prisma__AvalClient<AvalGetPayload<T>>>

    /**
     * Count the number of Avals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalCountArgs} args - Arguments to filter Avals to count.
     * @example
     * // Count the number of Avals
     * const count = await prisma.aval.count({
     *   where: {
     *     // ... the filter for the Avals we want to count
     *   }
     * })
    **/
    count<T extends AvalCountArgs>(
      args?: Subset<T, AvalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvalAggregateArgs>(args: Subset<T, AvalAggregateArgs>): PrismaPromise<GetAvalAggregateType<T>>

    /**
     * Group by Aval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvalGroupByArgs['orderBy'] }
        : { orderBy?: AvalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AvalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    phones<T extends PhoneFindManyArgs = {}>(args?: Subset<T, PhoneFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Phone>>, PrismaPromise<Array<PhoneGetPayload<T>>>>;

    documents<T extends DocumentFindManyArgs = {}>(args?: Subset<T, DocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Aval findUnique
   */
  export type AvalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * Throw an Error if a Aval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Aval to fetch.
     * 
    **/
    where: AvalWhereUniqueInput
  }


  /**
   * Aval findFirst
   */
  export type AvalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * Throw an Error if a Aval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Aval to fetch.
     * 
    **/
    where?: AvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avals to fetch.
     * 
    **/
    orderBy?: Enumerable<AvalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avals.
     * 
    **/
    cursor?: AvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avals.
     * 
    **/
    distinct?: Enumerable<AvalScalarFieldEnum>
  }


  /**
   * Aval findMany
   */
  export type AvalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * Filter, which Avals to fetch.
     * 
    **/
    where?: AvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avals to fetch.
     * 
    **/
    orderBy?: Enumerable<AvalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avals.
     * 
    **/
    cursor?: AvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AvalScalarFieldEnum>
  }


  /**
   * Aval create
   */
  export type AvalCreateArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * The data needed to create a Aval.
     * 
    **/
    data: XOR<AvalCreateInput, AvalUncheckedCreateInput>
  }


  /**
   * Aval createMany
   */
  export type AvalCreateManyArgs = {
    data: Enumerable<AvalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Aval update
   */
  export type AvalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * The data needed to update a Aval.
     * 
    **/
    data: XOR<AvalUpdateInput, AvalUncheckedUpdateInput>
    /**
     * Choose, which Aval to update.
     * 
    **/
    where: AvalWhereUniqueInput
  }


  /**
   * Aval updateMany
   */
  export type AvalUpdateManyArgs = {
    data: XOR<AvalUpdateManyMutationInput, AvalUncheckedUpdateManyInput>
    where?: AvalWhereInput
  }


  /**
   * Aval upsert
   */
  export type AvalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * The filter to search for the Aval to update in case it exists.
     * 
    **/
    where: AvalWhereUniqueInput
    /**
     * In case the Aval found by the `where` argument doesn't exist, create a new Aval with this data.
     * 
    **/
    create: XOR<AvalCreateInput, AvalUncheckedCreateInput>
    /**
     * In case the Aval was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AvalUpdateInput, AvalUncheckedUpdateInput>
  }


  /**
   * Aval delete
   */
  export type AvalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
    /**
     * Filter which Aval to delete.
     * 
    **/
    where: AvalWhereUniqueInput
  }


  /**
   * Aval deleteMany
   */
  export type AvalDeleteManyArgs = {
    where?: AvalWhereInput
  }


  /**
   * Aval without action
   */
  export type AvalArgs = {
    /**
     * Select specific fields to fetch from the Aval
     * 
    **/
    select?: AvalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AvalInclude | null
  }



  /**
   * Model Borrower
   */


  export type AggregateBorrower = {
    _count: BorrowerCountAggregateOutputType | null
    _min: BorrowerMinAggregateOutputType | null
    _max: BorrowerMaxAggregateOutputType | null
  }

  export type BorrowerMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowerCountAggregateOutputType = {
    id: number
    name: number
    address: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BorrowerMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowerMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowerCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BorrowerAggregateArgs = {
    /**
     * Filter which Borrower to aggregate.
     * 
    **/
    where?: BorrowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrowers to fetch.
     * 
    **/
    orderBy?: Enumerable<BorrowerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BorrowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrowers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Borrowers
    **/
    _count?: true | BorrowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowerMaxAggregateInputType
  }

  export type GetBorrowerAggregateType<T extends BorrowerAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrower[P]>
      : GetScalarType<T[P], AggregateBorrower[P]>
  }




  export type BorrowerGroupByArgs = {
    where?: BorrowerWhereInput
    orderBy?: Enumerable<BorrowerOrderByWithAggregationInput>
    by: Array<BorrowerScalarFieldEnum>
    having?: BorrowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowerCountAggregateInputType | true
    _min?: BorrowerMinAggregateInputType
    _max?: BorrowerMaxAggregateInputType
  }


  export type BorrowerGroupByOutputType = {
    id: string
    name: string
    address: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: BorrowerCountAggregateOutputType | null
    _min: BorrowerMinAggregateOutputType | null
    _max: BorrowerMaxAggregateOutputType | null
  }

  type GetBorrowerGroupByPayload<T extends BorrowerGroupByArgs> = Promise<
    Array<
      PickArray<BorrowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowerGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowerGroupByOutputType[P]>
        }
      >
    >


  export type BorrowerSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    email?: boolean
    phones?: boolean | PhoneFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    Contract?: boolean | ContractFindManyArgs
    Local?: boolean | LocalFindManyArgs
    _count?: boolean | BorrowerCountOutputTypeArgs
  }

  export type BorrowerInclude = {
    phones?: boolean | PhoneFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    Contract?: boolean | ContractFindManyArgs
    Local?: boolean | LocalFindManyArgs
    _count?: boolean | BorrowerCountOutputTypeArgs
  }

  export type BorrowerGetPayload<
    S extends boolean | null | undefined | BorrowerArgs,
    U = keyof S
      > = S extends true
        ? Borrower
    : S extends undefined
    ? never
    : S extends BorrowerArgs | BorrowerFindManyArgs
    ?'include' extends U
    ? Borrower  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['include'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['include'][P]>>  :
        P extends 'Contract'
        ? Array < ContractGetPayload<S['include'][P]>>  :
        P extends 'Local'
        ? Array < LocalGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? BorrowerCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Borrower ?Borrower [P]
  : 
          P extends 'phones'
        ? Array < PhoneGetPayload<S['select'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['select'][P]>>  :
        P extends 'Contract'
        ? Array < ContractGetPayload<S['select'][P]>>  :
        P extends 'Local'
        ? Array < LocalGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? BorrowerCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Borrower
  : Borrower


  type BorrowerCountArgs = Merge<
    Omit<BorrowerFindManyArgs, 'select' | 'include'> & {
      select?: BorrowerCountAggregateInputType | true
    }
  >

  export interface BorrowerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Borrower that matches the filter.
     * @param {BorrowerFindUniqueArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BorrowerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BorrowerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Borrower'> extends True ? CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>> : CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>

    /**
     * Find the first Borrower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerFindFirstArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BorrowerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BorrowerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Borrower'> extends True ? CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>> : CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>

    /**
     * Find zero or more Borrowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borrowers
     * const borrowers = await prisma.borrower.findMany()
     * 
     * // Get first 10 Borrowers
     * const borrowers = await prisma.borrower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowerWithIdOnly = await prisma.borrower.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BorrowerFindManyArgs>(
      args?: SelectSubset<T, BorrowerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Borrower>>, PrismaPromise<Array<BorrowerGetPayload<T>>>>

    /**
     * Create a Borrower.
     * @param {BorrowerCreateArgs} args - Arguments to create a Borrower.
     * @example
     * // Create one Borrower
     * const Borrower = await prisma.borrower.create({
     *   data: {
     *     // ... data to create a Borrower
     *   }
     * })
     * 
    **/
    create<T extends BorrowerCreateArgs>(
      args: SelectSubset<T, BorrowerCreateArgs>
    ): CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>>

    /**
     * Create many Borrowers.
     *     @param {BorrowerCreateManyArgs} args - Arguments to create many Borrowers.
     *     @example
     *     // Create many Borrowers
     *     const borrower = await prisma.borrower.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BorrowerCreateManyArgs>(
      args?: SelectSubset<T, BorrowerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Borrower.
     * @param {BorrowerDeleteArgs} args - Arguments to delete one Borrower.
     * @example
     * // Delete one Borrower
     * const Borrower = await prisma.borrower.delete({
     *   where: {
     *     // ... filter to delete one Borrower
     *   }
     * })
     * 
    **/
    delete<T extends BorrowerDeleteArgs>(
      args: SelectSubset<T, BorrowerDeleteArgs>
    ): CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>>

    /**
     * Update one Borrower.
     * @param {BorrowerUpdateArgs} args - Arguments to update one Borrower.
     * @example
     * // Update one Borrower
     * const borrower = await prisma.borrower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BorrowerUpdateArgs>(
      args: SelectSubset<T, BorrowerUpdateArgs>
    ): CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>>

    /**
     * Delete zero or more Borrowers.
     * @param {BorrowerDeleteManyArgs} args - Arguments to filter Borrowers to delete.
     * @example
     * // Delete a few Borrowers
     * const { count } = await prisma.borrower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BorrowerDeleteManyArgs>(
      args?: SelectSubset<T, BorrowerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borrowers
     * const borrower = await prisma.borrower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BorrowerUpdateManyArgs>(
      args: SelectSubset<T, BorrowerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Borrower.
     * @param {BorrowerUpsertArgs} args - Arguments to update or create a Borrower.
     * @example
     * // Update or create a Borrower
     * const borrower = await prisma.borrower.upsert({
     *   create: {
     *     // ... data to create a Borrower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borrower we want to update
     *   }
     * })
    **/
    upsert<T extends BorrowerUpsertArgs>(
      args: SelectSubset<T, BorrowerUpsertArgs>
    ): CheckSelect<T, Prisma__BorrowerClient<Borrower>, Prisma__BorrowerClient<BorrowerGetPayload<T>>>

    /**
     * Count the number of Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerCountArgs} args - Arguments to filter Borrowers to count.
     * @example
     * // Count the number of Borrowers
     * const count = await prisma.borrower.count({
     *   where: {
     *     // ... the filter for the Borrowers we want to count
     *   }
     * })
    **/
    count<T extends BorrowerCountArgs>(
      args?: Subset<T, BorrowerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Borrower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowerAggregateArgs>(args: Subset<T, BorrowerAggregateArgs>): PrismaPromise<GetBorrowerAggregateType<T>>

    /**
     * Group by Borrower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorrowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowerGroupByArgs['orderBy'] }
        : { orderBy?: BorrowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorrowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Borrower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BorrowerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    phones<T extends PhoneFindManyArgs = {}>(args?: Subset<T, PhoneFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Phone>>, PrismaPromise<Array<PhoneGetPayload<T>>>>;

    documents<T extends DocumentFindManyArgs = {}>(args?: Subset<T, DocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>;

    Contract<T extends ContractFindManyArgs = {}>(args?: Subset<T, ContractFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Contract>>, PrismaPromise<Array<ContractGetPayload<T>>>>;

    Local<T extends LocalFindManyArgs = {}>(args?: Subset<T, LocalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Local>>, PrismaPromise<Array<LocalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Borrower findUnique
   */
  export type BorrowerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * Throw an Error if a Borrower can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Borrower to fetch.
     * 
    **/
    where: BorrowerWhereUniqueInput
  }


  /**
   * Borrower findFirst
   */
  export type BorrowerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * Throw an Error if a Borrower can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Borrower to fetch.
     * 
    **/
    where?: BorrowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrowers to fetch.
     * 
    **/
    orderBy?: Enumerable<BorrowerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Borrowers.
     * 
    **/
    cursor?: BorrowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrowers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Borrowers.
     * 
    **/
    distinct?: Enumerable<BorrowerScalarFieldEnum>
  }


  /**
   * Borrower findMany
   */
  export type BorrowerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * Filter, which Borrowers to fetch.
     * 
    **/
    where?: BorrowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrowers to fetch.
     * 
    **/
    orderBy?: Enumerable<BorrowerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Borrowers.
     * 
    **/
    cursor?: BorrowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrowers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BorrowerScalarFieldEnum>
  }


  /**
   * Borrower create
   */
  export type BorrowerCreateArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * The data needed to create a Borrower.
     * 
    **/
    data: XOR<BorrowerCreateInput, BorrowerUncheckedCreateInput>
  }


  /**
   * Borrower createMany
   */
  export type BorrowerCreateManyArgs = {
    data: Enumerable<BorrowerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Borrower update
   */
  export type BorrowerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * The data needed to update a Borrower.
     * 
    **/
    data: XOR<BorrowerUpdateInput, BorrowerUncheckedUpdateInput>
    /**
     * Choose, which Borrower to update.
     * 
    **/
    where: BorrowerWhereUniqueInput
  }


  /**
   * Borrower updateMany
   */
  export type BorrowerUpdateManyArgs = {
    data: XOR<BorrowerUpdateManyMutationInput, BorrowerUncheckedUpdateManyInput>
    where?: BorrowerWhereInput
  }


  /**
   * Borrower upsert
   */
  export type BorrowerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * The filter to search for the Borrower to update in case it exists.
     * 
    **/
    where: BorrowerWhereUniqueInput
    /**
     * In case the Borrower found by the `where` argument doesn't exist, create a new Borrower with this data.
     * 
    **/
    create: XOR<BorrowerCreateInput, BorrowerUncheckedCreateInput>
    /**
     * In case the Borrower was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BorrowerUpdateInput, BorrowerUncheckedUpdateInput>
  }


  /**
   * Borrower delete
   */
  export type BorrowerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
    /**
     * Filter which Borrower to delete.
     * 
    **/
    where: BorrowerWhereUniqueInput
  }


  /**
   * Borrower deleteMany
   */
  export type BorrowerDeleteManyArgs = {
    where?: BorrowerWhereInput
  }


  /**
   * Borrower without action
   */
  export type BorrowerArgs = {
    /**
     * Select specific fields to fetch from the Borrower
     * 
    **/
    select?: BorrowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BorrowerInclude | null
  }



  /**
   * Model Local
   */


  export type AggregateLocal = {
    _count: LocalCountAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  export type LocalMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    borrowerId: string | null
  }

  export type LocalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    borrowerId: string | null
  }

  export type LocalCountAggregateOutputType = {
    id: number
    name: number
    address: number
    createdAt: number
    updatedAt: number
    borrowerId: number
    _all: number
  }


  export type LocalMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    borrowerId?: true
  }

  export type LocalMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    borrowerId?: true
  }

  export type LocalCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    borrowerId?: true
    _all?: true
  }

  export type LocalAggregateArgs = {
    /**
     * Filter which Local to aggregate.
     * 
    **/
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locals
    **/
    _count?: true | LocalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalMaxAggregateInputType
  }

  export type GetLocalAggregateType<T extends LocalAggregateArgs> = {
        [P in keyof T & keyof AggregateLocal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocal[P]>
      : GetScalarType<T[P], AggregateLocal[P]>
  }




  export type LocalGroupByArgs = {
    where?: LocalWhereInput
    orderBy?: Enumerable<LocalOrderByWithAggregationInput>
    by: Array<LocalScalarFieldEnum>
    having?: LocalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalCountAggregateInputType | true
    _min?: LocalMinAggregateInputType
    _max?: LocalMaxAggregateInputType
  }


  export type LocalGroupByOutputType = {
    id: string
    name: string
    address: string
    createdAt: Date
    updatedAt: Date
    borrowerId: string
    _count: LocalCountAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  type GetLocalGroupByPayload<T extends LocalGroupByArgs> = Promise<
    Array<
      PickArray<LocalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalGroupByOutputType[P]>
            : GetScalarType<T[P], LocalGroupByOutputType[P]>
        }
      >
    >


  export type LocalSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    borrower?: boolean | BorrowerArgs
    borrowerId?: boolean
  }

  export type LocalInclude = {
    borrower?: boolean | BorrowerArgs
  }

  export type LocalGetPayload<
    S extends boolean | null | undefined | LocalArgs,
    U = keyof S
      > = S extends true
        ? Local
    : S extends undefined
    ? never
    : S extends LocalArgs | LocalFindManyArgs
    ?'include' extends U
    ? Local  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'borrower'
        ? BorrowerGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Local ?Local [P]
  : 
          P extends 'borrower'
        ? BorrowerGetPayload<S['select'][P]> : never
  } 
    : Local
  : Local


  type LocalCountArgs = Merge<
    Omit<LocalFindManyArgs, 'select' | 'include'> & {
      select?: LocalCountAggregateInputType | true
    }
  >

  export interface LocalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Local that matches the filter.
     * @param {LocalFindUniqueArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LocalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Local'> extends True ? CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>> : CheckSelect<T, Prisma__LocalClient<Local | null >, Prisma__LocalClient<LocalGetPayload<T> | null >>

    /**
     * Find the first Local that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindFirstArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LocalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Local'> extends True ? CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>> : CheckSelect<T, Prisma__LocalClient<Local | null >, Prisma__LocalClient<LocalGetPayload<T> | null >>

    /**
     * Find zero or more Locals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locals
     * const locals = await prisma.local.findMany()
     * 
     * // Get first 10 Locals
     * const locals = await prisma.local.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localWithIdOnly = await prisma.local.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocalFindManyArgs>(
      args?: SelectSubset<T, LocalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Local>>, PrismaPromise<Array<LocalGetPayload<T>>>>

    /**
     * Create a Local.
     * @param {LocalCreateArgs} args - Arguments to create a Local.
     * @example
     * // Create one Local
     * const Local = await prisma.local.create({
     *   data: {
     *     // ... data to create a Local
     *   }
     * })
     * 
    **/
    create<T extends LocalCreateArgs>(
      args: SelectSubset<T, LocalCreateArgs>
    ): CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>>

    /**
     * Create many Locals.
     *     @param {LocalCreateManyArgs} args - Arguments to create many Locals.
     *     @example
     *     // Create many Locals
     *     const local = await prisma.local.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocalCreateManyArgs>(
      args?: SelectSubset<T, LocalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Local.
     * @param {LocalDeleteArgs} args - Arguments to delete one Local.
     * @example
     * // Delete one Local
     * const Local = await prisma.local.delete({
     *   where: {
     *     // ... filter to delete one Local
     *   }
     * })
     * 
    **/
    delete<T extends LocalDeleteArgs>(
      args: SelectSubset<T, LocalDeleteArgs>
    ): CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>>

    /**
     * Update one Local.
     * @param {LocalUpdateArgs} args - Arguments to update one Local.
     * @example
     * // Update one Local
     * const local = await prisma.local.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocalUpdateArgs>(
      args: SelectSubset<T, LocalUpdateArgs>
    ): CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>>

    /**
     * Delete zero or more Locals.
     * @param {LocalDeleteManyArgs} args - Arguments to filter Locals to delete.
     * @example
     * // Delete a few Locals
     * const { count } = await prisma.local.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocalDeleteManyArgs>(
      args?: SelectSubset<T, LocalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locals
     * const local = await prisma.local.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocalUpdateManyArgs>(
      args: SelectSubset<T, LocalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Local.
     * @param {LocalUpsertArgs} args - Arguments to update or create a Local.
     * @example
     * // Update or create a Local
     * const local = await prisma.local.upsert({
     *   create: {
     *     // ... data to create a Local
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Local we want to update
     *   }
     * })
    **/
    upsert<T extends LocalUpsertArgs>(
      args: SelectSubset<T, LocalUpsertArgs>
    ): CheckSelect<T, Prisma__LocalClient<Local>, Prisma__LocalClient<LocalGetPayload<T>>>

    /**
     * Count the number of Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalCountArgs} args - Arguments to filter Locals to count.
     * @example
     * // Count the number of Locals
     * const count = await prisma.local.count({
     *   where: {
     *     // ... the filter for the Locals we want to count
     *   }
     * })
    **/
    count<T extends LocalCountArgs>(
      args?: Subset<T, LocalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalAggregateArgs>(args: Subset<T, LocalAggregateArgs>): PrismaPromise<GetLocalAggregateType<T>>

    /**
     * Group by Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalGroupByArgs['orderBy'] }
        : { orderBy?: LocalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Local.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LocalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    borrower<T extends BorrowerArgs = {}>(args?: Subset<T, BorrowerArgs>): CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Local findUnique
   */
  export type LocalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * Throw an Error if a Local can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Local to fetch.
     * 
    **/
    where: LocalWhereUniqueInput
  }


  /**
   * Local findFirst
   */
  export type LocalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * Throw an Error if a Local can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Local to fetch.
     * 
    **/
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locals.
     * 
    **/
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locals.
     * 
    **/
    distinct?: Enumerable<LocalScalarFieldEnum>
  }


  /**
   * Local findMany
   */
  export type LocalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * Filter, which Locals to fetch.
     * 
    **/
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locals.
     * 
    **/
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocalScalarFieldEnum>
  }


  /**
   * Local create
   */
  export type LocalCreateArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * The data needed to create a Local.
     * 
    **/
    data: XOR<LocalCreateInput, LocalUncheckedCreateInput>
  }


  /**
   * Local createMany
   */
  export type LocalCreateManyArgs = {
    data: Enumerable<LocalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Local update
   */
  export type LocalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * The data needed to update a Local.
     * 
    **/
    data: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
    /**
     * Choose, which Local to update.
     * 
    **/
    where: LocalWhereUniqueInput
  }


  /**
   * Local updateMany
   */
  export type LocalUpdateManyArgs = {
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyInput>
    where?: LocalWhereInput
  }


  /**
   * Local upsert
   */
  export type LocalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * The filter to search for the Local to update in case it exists.
     * 
    **/
    where: LocalWhereUniqueInput
    /**
     * In case the Local found by the `where` argument doesn't exist, create a new Local with this data.
     * 
    **/
    create: XOR<LocalCreateInput, LocalUncheckedCreateInput>
    /**
     * In case the Local was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
  }


  /**
   * Local delete
   */
  export type LocalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
    /**
     * Filter which Local to delete.
     * 
    **/
    where: LocalWhereUniqueInput
  }


  /**
   * Local deleteMany
   */
  export type LocalDeleteManyArgs = {
    where?: LocalWhereInput
  }


  /**
   * Local without action
   */
  export type LocalArgs = {
    /**
     * Select specific fields to fetch from the Local
     * 
    **/
    select?: LocalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalInclude | null
  }



  /**
   * Model Phone
   */


  export type AggregatePhone = {
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  export type PhoneMinAggregateOutputType = {
    id: string | null
    number: string | null
    borrowerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avalId: string | null
    employeeId: string | null
  }

  export type PhoneMaxAggregateOutputType = {
    id: string | null
    number: string | null
    borrowerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avalId: string | null
    employeeId: string | null
  }

  export type PhoneCountAggregateOutputType = {
    id: number
    number: number
    borrowerId: number
    createdAt: number
    updatedAt: number
    avalId: number
    employeeId: number
    _all: number
  }


  export type PhoneMinAggregateInputType = {
    id?: true
    number?: true
    borrowerId?: true
    createdAt?: true
    updatedAt?: true
    avalId?: true
    employeeId?: true
  }

  export type PhoneMaxAggregateInputType = {
    id?: true
    number?: true
    borrowerId?: true
    createdAt?: true
    updatedAt?: true
    avalId?: true
    employeeId?: true
  }

  export type PhoneCountAggregateInputType = {
    id?: true
    number?: true
    borrowerId?: true
    createdAt?: true
    updatedAt?: true
    avalId?: true
    employeeId?: true
    _all?: true
  }

  export type PhoneAggregateArgs = {
    /**
     * Filter which Phone to aggregate.
     * 
    **/
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     * 
    **/
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phones
    **/
    _count?: true | PhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneMaxAggregateInputType
  }

  export type GetPhoneAggregateType<T extends PhoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhone[P]>
      : GetScalarType<T[P], AggregatePhone[P]>
  }




  export type PhoneGroupByArgs = {
    where?: PhoneWhereInput
    orderBy?: Enumerable<PhoneOrderByWithAggregationInput>
    by: Array<PhoneScalarFieldEnum>
    having?: PhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneCountAggregateInputType | true
    _min?: PhoneMinAggregateInputType
    _max?: PhoneMaxAggregateInputType
  }


  export type PhoneGroupByOutputType = {
    id: string
    number: string
    borrowerId: string | null
    createdAt: Date
    updatedAt: Date
    avalId: string | null
    employeeId: string | null
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  type GetPhoneGroupByPayload<T extends PhoneGroupByArgs> = Promise<
    Array<
      PickArray<PhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneGroupByOutputType[P]>
        }
      >
    >


  export type PhoneSelect = {
    id?: boolean
    number?: boolean
    Borrower?: boolean | BorrowerArgs
    borrowerId?: boolean
    Employee?: boolean | EmployeeArgs
    createdAt?: boolean
    updatedAt?: boolean
    aval?: boolean | AvalArgs
    avalId?: boolean
    employeeId?: boolean
  }

  export type PhoneInclude = {
    Borrower?: boolean | BorrowerArgs
    Employee?: boolean | EmployeeArgs
    aval?: boolean | AvalArgs
  }

  export type PhoneGetPayload<
    S extends boolean | null | undefined | PhoneArgs,
    U = keyof S
      > = S extends true
        ? Phone
    : S extends undefined
    ? never
    : S extends PhoneArgs | PhoneFindManyArgs
    ?'include' extends U
    ? Phone  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Borrower'
        ? BorrowerGetPayload<S['include'][P]> | null :
        P extends 'Employee'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'aval'
        ? AvalGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Phone ?Phone [P]
  : 
          P extends 'Borrower'
        ? BorrowerGetPayload<S['select'][P]> | null :
        P extends 'Employee'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'aval'
        ? AvalGetPayload<S['select'][P]> | null : never
  } 
    : Phone
  : Phone


  type PhoneCountArgs = Merge<
    Omit<PhoneFindManyArgs, 'select' | 'include'> & {
      select?: PhoneCountAggregateInputType | true
    }
  >

  export interface PhoneDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Phone that matches the filter.
     * @param {PhoneFindUniqueArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhoneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhoneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Phone'> extends True ? CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>> : CheckSelect<T, Prisma__PhoneClient<Phone | null >, Prisma__PhoneClient<PhoneGetPayload<T> | null >>

    /**
     * Find the first Phone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhoneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhoneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Phone'> extends True ? CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>> : CheckSelect<T, Prisma__PhoneClient<Phone | null >, Prisma__PhoneClient<PhoneGetPayload<T> | null >>

    /**
     * Find zero or more Phones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phones
     * const phones = await prisma.phone.findMany()
     * 
     * // Get first 10 Phones
     * const phones = await prisma.phone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneWithIdOnly = await prisma.phone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhoneFindManyArgs>(
      args?: SelectSubset<T, PhoneFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Phone>>, PrismaPromise<Array<PhoneGetPayload<T>>>>

    /**
     * Create a Phone.
     * @param {PhoneCreateArgs} args - Arguments to create a Phone.
     * @example
     * // Create one Phone
     * const Phone = await prisma.phone.create({
     *   data: {
     *     // ... data to create a Phone
     *   }
     * })
     * 
    **/
    create<T extends PhoneCreateArgs>(
      args: SelectSubset<T, PhoneCreateArgs>
    ): CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>>

    /**
     * Create many Phones.
     *     @param {PhoneCreateManyArgs} args - Arguments to create many Phones.
     *     @example
     *     // Create many Phones
     *     const phone = await prisma.phone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhoneCreateManyArgs>(
      args?: SelectSubset<T, PhoneCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Phone.
     * @param {PhoneDeleteArgs} args - Arguments to delete one Phone.
     * @example
     * // Delete one Phone
     * const Phone = await prisma.phone.delete({
     *   where: {
     *     // ... filter to delete one Phone
     *   }
     * })
     * 
    **/
    delete<T extends PhoneDeleteArgs>(
      args: SelectSubset<T, PhoneDeleteArgs>
    ): CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>>

    /**
     * Update one Phone.
     * @param {PhoneUpdateArgs} args - Arguments to update one Phone.
     * @example
     * // Update one Phone
     * const phone = await prisma.phone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhoneUpdateArgs>(
      args: SelectSubset<T, PhoneUpdateArgs>
    ): CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>>

    /**
     * Delete zero or more Phones.
     * @param {PhoneDeleteManyArgs} args - Arguments to filter Phones to delete.
     * @example
     * // Delete a few Phones
     * const { count } = await prisma.phone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhoneDeleteManyArgs>(
      args?: SelectSubset<T, PhoneDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phones
     * const phone = await prisma.phone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhoneUpdateManyArgs>(
      args: SelectSubset<T, PhoneUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Phone.
     * @param {PhoneUpsertArgs} args - Arguments to update or create a Phone.
     * @example
     * // Update or create a Phone
     * const phone = await prisma.phone.upsert({
     *   create: {
     *     // ... data to create a Phone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phone we want to update
     *   }
     * })
    **/
    upsert<T extends PhoneUpsertArgs>(
      args: SelectSubset<T, PhoneUpsertArgs>
    ): CheckSelect<T, Prisma__PhoneClient<Phone>, Prisma__PhoneClient<PhoneGetPayload<T>>>

    /**
     * Count the number of Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCountArgs} args - Arguments to filter Phones to count.
     * @example
     * // Count the number of Phones
     * const count = await prisma.phone.count({
     *   where: {
     *     // ... the filter for the Phones we want to count
     *   }
     * })
    **/
    count<T extends PhoneCountArgs>(
      args?: Subset<T, PhoneCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneAggregateArgs>(args: Subset<T, PhoneAggregateArgs>): PrismaPromise<GetPhoneAggregateType<T>>

    /**
     * Group by Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneGroupByArgs['orderBy'] }
        : { orderBy?: PhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhoneClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Borrower<T extends BorrowerArgs = {}>(args?: Subset<T, BorrowerArgs>): CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>;

    Employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    aval<T extends AvalArgs = {}>(args?: Subset<T, AvalArgs>): CheckSelect<T, Prisma__AvalClient<Aval | null >, Prisma__AvalClient<AvalGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Phone findUnique
   */
  export type PhoneFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * Throw an Error if a Phone can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Phone to fetch.
     * 
    **/
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone findFirst
   */
  export type PhoneFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * Throw an Error if a Phone can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Phone to fetch.
     * 
    **/
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     * 
    **/
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     * 
    **/
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     * 
    **/
    distinct?: Enumerable<PhoneScalarFieldEnum>
  }


  /**
   * Phone findMany
   */
  export type PhoneFindManyArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * Filter, which Phones to fetch.
     * 
    **/
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     * 
    **/
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phones.
     * 
    **/
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PhoneScalarFieldEnum>
  }


  /**
   * Phone create
   */
  export type PhoneCreateArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * The data needed to create a Phone.
     * 
    **/
    data: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
  }


  /**
   * Phone createMany
   */
  export type PhoneCreateManyArgs = {
    data: Enumerable<PhoneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Phone update
   */
  export type PhoneUpdateArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * The data needed to update a Phone.
     * 
    **/
    data: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
    /**
     * Choose, which Phone to update.
     * 
    **/
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone updateMany
   */
  export type PhoneUpdateManyArgs = {
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyInput>
    where?: PhoneWhereInput
  }


  /**
   * Phone upsert
   */
  export type PhoneUpsertArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * The filter to search for the Phone to update in case it exists.
     * 
    **/
    where: PhoneWhereUniqueInput
    /**
     * In case the Phone found by the `where` argument doesn't exist, create a new Phone with this data.
     * 
    **/
    create: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
    /**
     * In case the Phone was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
  }


  /**
   * Phone delete
   */
  export type PhoneDeleteArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
    /**
     * Filter which Phone to delete.
     * 
    **/
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone deleteMany
   */
  export type PhoneDeleteManyArgs = {
    where?: PhoneWhereInput
  }


  /**
   * Phone without action
   */
  export type PhoneArgs = {
    /**
     * Select specific fields to fetch from the Phone
     * 
    **/
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhoneInclude | null
  }



  /**
   * Model ContractType
   */


  export type AggregateContractType = {
    _count: ContractTypeCountAggregateOutputType | null
    _avg: ContractTypeAvgAggregateOutputType | null
    _sum: ContractTypeSumAggregateOutputType | null
    _min: ContractTypeMinAggregateOutputType | null
    _max: ContractTypeMaxAggregateOutputType | null
  }

  export type ContractTypeAvgAggregateOutputType = {
    monthDuration: number | null
    amount: Decimal | null
  }

  export type ContractTypeSumAggregateOutputType = {
    monthDuration: number | null
    amount: Decimal | null
  }

  export type ContractTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    monthDuration: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    monthDuration: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractTypeCountAggregateOutputType = {
    id: number
    name: number
    monthDuration: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractTypeAvgAggregateInputType = {
    monthDuration?: true
    amount?: true
  }

  export type ContractTypeSumAggregateInputType = {
    monthDuration?: true
    amount?: true
  }

  export type ContractTypeMinAggregateInputType = {
    id?: true
    name?: true
    monthDuration?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractTypeMaxAggregateInputType = {
    id?: true
    name?: true
    monthDuration?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractTypeCountAggregateInputType = {
    id?: true
    name?: true
    monthDuration?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractTypeAggregateArgs = {
    /**
     * Filter which ContractType to aggregate.
     * 
    **/
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractTypes
    **/
    _count?: true | ContractTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractTypeMaxAggregateInputType
  }

  export type GetContractTypeAggregateType<T extends ContractTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContractType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractType[P]>
      : GetScalarType<T[P], AggregateContractType[P]>
  }




  export type ContractTypeGroupByArgs = {
    where?: ContractTypeWhereInput
    orderBy?: Enumerable<ContractTypeOrderByWithAggregationInput>
    by: Array<ContractTypeScalarFieldEnum>
    having?: ContractTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractTypeCountAggregateInputType | true
    _avg?: ContractTypeAvgAggregateInputType
    _sum?: ContractTypeSumAggregateInputType
    _min?: ContractTypeMinAggregateInputType
    _max?: ContractTypeMaxAggregateInputType
  }


  export type ContractTypeGroupByOutputType = {
    id: string
    name: string
    monthDuration: number
    amount: Decimal
    createdAt: Date
    updatedAt: Date | null
    _count: ContractTypeCountAggregateOutputType | null
    _avg: ContractTypeAvgAggregateOutputType | null
    _sum: ContractTypeSumAggregateOutputType | null
    _min: ContractTypeMinAggregateOutputType | null
    _max: ContractTypeMaxAggregateOutputType | null
  }

  type GetContractTypeGroupByPayload<T extends ContractTypeGroupByArgs> = Promise<
    Array<
      PickArray<ContractTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContractTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContractTypeSelect = {
    id?: boolean
    name?: boolean
    monthDuration?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractTypeGetPayload<
    S extends boolean | null | undefined | ContractTypeArgs,
    U = keyof S
      > = S extends true
        ? ContractType
    : S extends undefined
    ? never
    : S extends ContractTypeArgs | ContractTypeFindManyArgs
    ?'include' extends U
    ? ContractType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ContractType ?ContractType [P]
  : 
     never
  } 
    : ContractType
  : ContractType


  type ContractTypeCountArgs = Merge<
    Omit<ContractTypeFindManyArgs, 'select' | 'include'> & {
      select?: ContractTypeCountAggregateInputType | true
    }
  >

  export interface ContractTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ContractType that matches the filter.
     * @param {ContractTypeFindUniqueArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContractTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ContractType'> extends True ? CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>> : CheckSelect<T, Prisma__ContractTypeClient<ContractType | null >, Prisma__ContractTypeClient<ContractTypeGetPayload<T> | null >>

    /**
     * Find the first ContractType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeFindFirstArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContractTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ContractType'> extends True ? CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>> : CheckSelect<T, Prisma__ContractTypeClient<ContractType | null >, Prisma__ContractTypeClient<ContractTypeGetPayload<T> | null >>

    /**
     * Find zero or more ContractTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractTypes
     * const contractTypes = await prisma.contractType.findMany()
     * 
     * // Get first 10 ContractTypes
     * const contractTypes = await prisma.contractType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractTypeWithIdOnly = await prisma.contractType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractTypeFindManyArgs>(
      args?: SelectSubset<T, ContractTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ContractType>>, PrismaPromise<Array<ContractTypeGetPayload<T>>>>

    /**
     * Create a ContractType.
     * @param {ContractTypeCreateArgs} args - Arguments to create a ContractType.
     * @example
     * // Create one ContractType
     * const ContractType = await prisma.contractType.create({
     *   data: {
     *     // ... data to create a ContractType
     *   }
     * })
     * 
    **/
    create<T extends ContractTypeCreateArgs>(
      args: SelectSubset<T, ContractTypeCreateArgs>
    ): CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>>

    /**
     * Create many ContractTypes.
     *     @param {ContractTypeCreateManyArgs} args - Arguments to create many ContractTypes.
     *     @example
     *     // Create many ContractTypes
     *     const contractType = await prisma.contractType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractTypeCreateManyArgs>(
      args?: SelectSubset<T, ContractTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ContractType.
     * @param {ContractTypeDeleteArgs} args - Arguments to delete one ContractType.
     * @example
     * // Delete one ContractType
     * const ContractType = await prisma.contractType.delete({
     *   where: {
     *     // ... filter to delete one ContractType
     *   }
     * })
     * 
    **/
    delete<T extends ContractTypeDeleteArgs>(
      args: SelectSubset<T, ContractTypeDeleteArgs>
    ): CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>>

    /**
     * Update one ContractType.
     * @param {ContractTypeUpdateArgs} args - Arguments to update one ContractType.
     * @example
     * // Update one ContractType
     * const contractType = await prisma.contractType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractTypeUpdateArgs>(
      args: SelectSubset<T, ContractTypeUpdateArgs>
    ): CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>>

    /**
     * Delete zero or more ContractTypes.
     * @param {ContractTypeDeleteManyArgs} args - Arguments to filter ContractTypes to delete.
     * @example
     * // Delete a few ContractTypes
     * const { count } = await prisma.contractType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractTypeDeleteManyArgs>(
      args?: SelectSubset<T, ContractTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractTypes
     * const contractType = await prisma.contractType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractTypeUpdateManyArgs>(
      args: SelectSubset<T, ContractTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractType.
     * @param {ContractTypeUpsertArgs} args - Arguments to update or create a ContractType.
     * @example
     * // Update or create a ContractType
     * const contractType = await prisma.contractType.upsert({
     *   create: {
     *     // ... data to create a ContractType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractType we want to update
     *   }
     * })
    **/
    upsert<T extends ContractTypeUpsertArgs>(
      args: SelectSubset<T, ContractTypeUpsertArgs>
    ): CheckSelect<T, Prisma__ContractTypeClient<ContractType>, Prisma__ContractTypeClient<ContractTypeGetPayload<T>>>

    /**
     * Count the number of ContractTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeCountArgs} args - Arguments to filter ContractTypes to count.
     * @example
     * // Count the number of ContractTypes
     * const count = await prisma.contractType.count({
     *   where: {
     *     // ... the filter for the ContractTypes we want to count
     *   }
     * })
    **/
    count<T extends ContractTypeCountArgs>(
      args?: Subset<T, ContractTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractTypeAggregateArgs>(args: Subset<T, ContractTypeAggregateArgs>): PrismaPromise<GetContractTypeAggregateType<T>>

    /**
     * Group by ContractType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContractTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContractTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ContractType findUnique
   */
  export type ContractTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * Throw an Error if a ContractType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ContractType to fetch.
     * 
    **/
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType findFirst
   */
  export type ContractTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * Throw an Error if a ContractType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ContractType to fetch.
     * 
    **/
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractTypes.
     * 
    **/
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractTypes.
     * 
    **/
    distinct?: Enumerable<ContractTypeScalarFieldEnum>
  }


  /**
   * ContractType findMany
   */
  export type ContractTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * Filter, which ContractTypes to fetch.
     * 
    **/
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractTypes.
     * 
    **/
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContractTypeScalarFieldEnum>
  }


  /**
   * ContractType create
   */
  export type ContractTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * The data needed to create a ContractType.
     * 
    **/
    data: XOR<ContractTypeCreateInput, ContractTypeUncheckedCreateInput>
  }


  /**
   * ContractType createMany
   */
  export type ContractTypeCreateManyArgs = {
    data: Enumerable<ContractTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ContractType update
   */
  export type ContractTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * The data needed to update a ContractType.
     * 
    **/
    data: XOR<ContractTypeUpdateInput, ContractTypeUncheckedUpdateInput>
    /**
     * Choose, which ContractType to update.
     * 
    **/
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType updateMany
   */
  export type ContractTypeUpdateManyArgs = {
    data: XOR<ContractTypeUpdateManyMutationInput, ContractTypeUncheckedUpdateManyInput>
    where?: ContractTypeWhereInput
  }


  /**
   * ContractType upsert
   */
  export type ContractTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * The filter to search for the ContractType to update in case it exists.
     * 
    **/
    where: ContractTypeWhereUniqueInput
    /**
     * In case the ContractType found by the `where` argument doesn't exist, create a new ContractType with this data.
     * 
    **/
    create: XOR<ContractTypeCreateInput, ContractTypeUncheckedCreateInput>
    /**
     * In case the ContractType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ContractTypeUpdateInput, ContractTypeUncheckedUpdateInput>
  }


  /**
   * ContractType delete
   */
  export type ContractTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
    /**
     * Filter which ContractType to delete.
     * 
    **/
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType deleteMany
   */
  export type ContractTypeDeleteManyArgs = {
    where?: ContractTypeWhereInput
  }


  /**
   * ContractType without action
   */
  export type ContractTypeArgs = {
    /**
     * Select specific fields to fetch from the ContractType
     * 
    **/
    select?: ContractTypeSelect | null
  }



  /**
   * Model Loantype
   */


  export type AggregateLoantype = {
    _count: LoantypeCountAggregateOutputType | null
    _avg: LoantypeAvgAggregateOutputType | null
    _sum: LoantypeSumAggregateOutputType | null
    _min: LoantypeMinAggregateOutputType | null
    _max: LoantypeMaxAggregateOutputType | null
  }

  export type LoantypeAvgAggregateOutputType = {
    weekDuration: number | null
    rate: number | null
    overdueRate: number | null
  }

  export type LoantypeSumAggregateOutputType = {
    weekDuration: number | null
    rate: number | null
    overdueRate: number | null
  }

  export type LoantypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    weekDuration: number | null
    rate: number | null
    overdueRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoantypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weekDuration: number | null
    rate: number | null
    overdueRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoantypeCountAggregateOutputType = {
    id: number
    name: number
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoantypeAvgAggregateInputType = {
    weekDuration?: true
    rate?: true
    overdueRate?: true
  }

  export type LoantypeSumAggregateInputType = {
    weekDuration?: true
    rate?: true
    overdueRate?: true
  }

  export type LoantypeMinAggregateInputType = {
    id?: true
    name?: true
    weekDuration?: true
    rate?: true
    overdueRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoantypeMaxAggregateInputType = {
    id?: true
    name?: true
    weekDuration?: true
    rate?: true
    overdueRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoantypeCountAggregateInputType = {
    id?: true
    name?: true
    weekDuration?: true
    rate?: true
    overdueRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoantypeAggregateArgs = {
    /**
     * Filter which Loantype to aggregate.
     * 
    **/
    where?: LoantypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loantypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoantypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoantypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loantypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loantypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loantypes
    **/
    _count?: true | LoantypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoantypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoantypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoantypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoantypeMaxAggregateInputType
  }

  export type GetLoantypeAggregateType<T extends LoantypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLoantype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoantype[P]>
      : GetScalarType<T[P], AggregateLoantype[P]>
  }




  export type LoantypeGroupByArgs = {
    where?: LoantypeWhereInput
    orderBy?: Enumerable<LoantypeOrderByWithAggregationInput>
    by: Array<LoantypeScalarFieldEnum>
    having?: LoantypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoantypeCountAggregateInputType | true
    _avg?: LoantypeAvgAggregateInputType
    _sum?: LoantypeSumAggregateInputType
    _min?: LoantypeMinAggregateInputType
    _max?: LoantypeMaxAggregateInputType
  }


  export type LoantypeGroupByOutputType = {
    id: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt: Date
    updatedAt: Date
    _count: LoantypeCountAggregateOutputType | null
    _avg: LoantypeAvgAggregateOutputType | null
    _sum: LoantypeSumAggregateOutputType | null
    _min: LoantypeMinAggregateOutputType | null
    _max: LoantypeMaxAggregateOutputType | null
  }

  type GetLoantypeGroupByPayload<T extends LoantypeGroupByArgs> = Promise<
    Array<
      PickArray<LoantypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoantypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoantypeGroupByOutputType[P]>
            : GetScalarType<T[P], LoantypeGroupByOutputType[P]>
        }
      >
    >


  export type LoantypeSelect = {
    id?: boolean
    name?: boolean
    weekDuration?: boolean
    rate?: boolean
    overdueRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Loan?: boolean | LoanFindManyArgs
    _count?: boolean | LoantypeCountOutputTypeArgs
  }

  export type LoantypeInclude = {
    Loan?: boolean | LoanFindManyArgs
    _count?: boolean | LoantypeCountOutputTypeArgs
  }

  export type LoantypeGetPayload<
    S extends boolean | null | undefined | LoantypeArgs,
    U = keyof S
      > = S extends true
        ? Loantype
    : S extends undefined
    ? never
    : S extends LoantypeArgs | LoantypeFindManyArgs
    ?'include' extends U
    ? Loantype  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Loan'
        ? Array < LoanGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? LoantypeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Loantype ?Loantype [P]
  : 
          P extends 'Loan'
        ? Array < LoanGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? LoantypeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Loantype
  : Loantype


  type LoantypeCountArgs = Merge<
    Omit<LoantypeFindManyArgs, 'select' | 'include'> & {
      select?: LoantypeCountAggregateInputType | true
    }
  >

  export interface LoantypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Loantype that matches the filter.
     * @param {LoantypeFindUniqueArgs} args - Arguments to find a Loantype
     * @example
     * // Get one Loantype
     * const loantype = await prisma.loantype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoantypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoantypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Loantype'> extends True ? CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>> : CheckSelect<T, Prisma__LoantypeClient<Loantype | null >, Prisma__LoantypeClient<LoantypeGetPayload<T> | null >>

    /**
     * Find the first Loantype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeFindFirstArgs} args - Arguments to find a Loantype
     * @example
     * // Get one Loantype
     * const loantype = await prisma.loantype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoantypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoantypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Loantype'> extends True ? CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>> : CheckSelect<T, Prisma__LoantypeClient<Loantype | null >, Prisma__LoantypeClient<LoantypeGetPayload<T> | null >>

    /**
     * Find zero or more Loantypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loantypes
     * const loantypes = await prisma.loantype.findMany()
     * 
     * // Get first 10 Loantypes
     * const loantypes = await prisma.loantype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loantypeWithIdOnly = await prisma.loantype.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoantypeFindManyArgs>(
      args?: SelectSubset<T, LoantypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Loantype>>, PrismaPromise<Array<LoantypeGetPayload<T>>>>

    /**
     * Create a Loantype.
     * @param {LoantypeCreateArgs} args - Arguments to create a Loantype.
     * @example
     * // Create one Loantype
     * const Loantype = await prisma.loantype.create({
     *   data: {
     *     // ... data to create a Loantype
     *   }
     * })
     * 
    **/
    create<T extends LoantypeCreateArgs>(
      args: SelectSubset<T, LoantypeCreateArgs>
    ): CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>>

    /**
     * Create many Loantypes.
     *     @param {LoantypeCreateManyArgs} args - Arguments to create many Loantypes.
     *     @example
     *     // Create many Loantypes
     *     const loantype = await prisma.loantype.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoantypeCreateManyArgs>(
      args?: SelectSubset<T, LoantypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Loantype.
     * @param {LoantypeDeleteArgs} args - Arguments to delete one Loantype.
     * @example
     * // Delete one Loantype
     * const Loantype = await prisma.loantype.delete({
     *   where: {
     *     // ... filter to delete one Loantype
     *   }
     * })
     * 
    **/
    delete<T extends LoantypeDeleteArgs>(
      args: SelectSubset<T, LoantypeDeleteArgs>
    ): CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>>

    /**
     * Update one Loantype.
     * @param {LoantypeUpdateArgs} args - Arguments to update one Loantype.
     * @example
     * // Update one Loantype
     * const loantype = await prisma.loantype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoantypeUpdateArgs>(
      args: SelectSubset<T, LoantypeUpdateArgs>
    ): CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>>

    /**
     * Delete zero or more Loantypes.
     * @param {LoantypeDeleteManyArgs} args - Arguments to filter Loantypes to delete.
     * @example
     * // Delete a few Loantypes
     * const { count } = await prisma.loantype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoantypeDeleteManyArgs>(
      args?: SelectSubset<T, LoantypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loantypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loantypes
     * const loantype = await prisma.loantype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoantypeUpdateManyArgs>(
      args: SelectSubset<T, LoantypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Loantype.
     * @param {LoantypeUpsertArgs} args - Arguments to update or create a Loantype.
     * @example
     * // Update or create a Loantype
     * const loantype = await prisma.loantype.upsert({
     *   create: {
     *     // ... data to create a Loantype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loantype we want to update
     *   }
     * })
    **/
    upsert<T extends LoantypeUpsertArgs>(
      args: SelectSubset<T, LoantypeUpsertArgs>
    ): CheckSelect<T, Prisma__LoantypeClient<Loantype>, Prisma__LoantypeClient<LoantypeGetPayload<T>>>

    /**
     * Count the number of Loantypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeCountArgs} args - Arguments to filter Loantypes to count.
     * @example
     * // Count the number of Loantypes
     * const count = await prisma.loantype.count({
     *   where: {
     *     // ... the filter for the Loantypes we want to count
     *   }
     * })
    **/
    count<T extends LoantypeCountArgs>(
      args?: Subset<T, LoantypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoantypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loantype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoantypeAggregateArgs>(args: Subset<T, LoantypeAggregateArgs>): PrismaPromise<GetLoantypeAggregateType<T>>

    /**
     * Group by Loantype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoantypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoantypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoantypeGroupByArgs['orderBy'] }
        : { orderBy?: LoantypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoantypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoantypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loantype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoantypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Loan<T extends LoanFindManyArgs = {}>(args?: Subset<T, LoanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loan>>, PrismaPromise<Array<LoanGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Loantype findUnique
   */
  export type LoantypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * Throw an Error if a Loantype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Loantype to fetch.
     * 
    **/
    where: LoantypeWhereUniqueInput
  }


  /**
   * Loantype findFirst
   */
  export type LoantypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * Throw an Error if a Loantype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Loantype to fetch.
     * 
    **/
    where?: LoantypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loantypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoantypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loantypes.
     * 
    **/
    cursor?: LoantypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loantypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loantypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loantypes.
     * 
    **/
    distinct?: Enumerable<LoantypeScalarFieldEnum>
  }


  /**
   * Loantype findMany
   */
  export type LoantypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * Filter, which Loantypes to fetch.
     * 
    **/
    where?: LoantypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loantypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoantypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loantypes.
     * 
    **/
    cursor?: LoantypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loantypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loantypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoantypeScalarFieldEnum>
  }


  /**
   * Loantype create
   */
  export type LoantypeCreateArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * The data needed to create a Loantype.
     * 
    **/
    data: XOR<LoantypeCreateInput, LoantypeUncheckedCreateInput>
  }


  /**
   * Loantype createMany
   */
  export type LoantypeCreateManyArgs = {
    data: Enumerable<LoantypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Loantype update
   */
  export type LoantypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * The data needed to update a Loantype.
     * 
    **/
    data: XOR<LoantypeUpdateInput, LoantypeUncheckedUpdateInput>
    /**
     * Choose, which Loantype to update.
     * 
    **/
    where: LoantypeWhereUniqueInput
  }


  /**
   * Loantype updateMany
   */
  export type LoantypeUpdateManyArgs = {
    data: XOR<LoantypeUpdateManyMutationInput, LoantypeUncheckedUpdateManyInput>
    where?: LoantypeWhereInput
  }


  /**
   * Loantype upsert
   */
  export type LoantypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * The filter to search for the Loantype to update in case it exists.
     * 
    **/
    where: LoantypeWhereUniqueInput
    /**
     * In case the Loantype found by the `where` argument doesn't exist, create a new Loantype with this data.
     * 
    **/
    create: XOR<LoantypeCreateInput, LoantypeUncheckedCreateInput>
    /**
     * In case the Loantype was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoantypeUpdateInput, LoantypeUncheckedUpdateInput>
  }


  /**
   * Loantype delete
   */
  export type LoantypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
    /**
     * Filter which Loantype to delete.
     * 
    **/
    where: LoantypeWhereUniqueInput
  }


  /**
   * Loantype deleteMany
   */
  export type LoantypeDeleteManyArgs = {
    where?: LoantypeWhereInput
  }


  /**
   * Loantype without action
   */
  export type LoantypeArgs = {
    /**
     * Select specific fields to fetch from the Loantype
     * 
    **/
    select?: LoantypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoantypeInclude | null
  }



  /**
   * Model Contract
   */


  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ContractSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    borrowerId: string | null
    createdAt: Date | null
    dueDate: Date | null
    signDate: Date | null
    updatedAt: Date | null
    employeeId: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    borrowerId: string | null
    createdAt: Date | null
    dueDate: Date | null
    signDate: Date | null
    updatedAt: Date | null
    employeeId: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    amount: number
    borrowerId: number
    createdAt: number
    dueDate: number
    signDate: number
    updatedAt: number
    employeeId: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    amount?: true
  }

  export type ContractSumAggregateInputType = {
    amount?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    amount?: true
    borrowerId?: true
    createdAt?: true
    dueDate?: true
    signDate?: true
    updatedAt?: true
    employeeId?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    amount?: true
    borrowerId?: true
    createdAt?: true
    dueDate?: true
    signDate?: true
    updatedAt?: true
    employeeId?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    amount?: true
    borrowerId?: true
    createdAt?: true
    dueDate?: true
    signDate?: true
    updatedAt?: true
    employeeId?: true
    _all?: true
  }

  export type ContractAggregateArgs = {
    /**
     * Filter which Contract to aggregate.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs = {
    where?: ContractWhereInput
    orderBy?: Enumerable<ContractOrderByWithAggregationInput>
    by: Array<ContractScalarFieldEnum>
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }


  export type ContractGroupByOutputType = {
    id: string
    amount: Decimal
    borrowerId: string
    createdAt: Date
    dueDate: Date
    signDate: Date
    updatedAt: Date
    employeeId: string
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Promise<
    Array<
      PickArray<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect = {
    id?: boolean
    amount?: boolean
    borrower?: boolean | BorrowerArgs
    borrowerId?: boolean
    employee?: boolean | EmployeeArgs
    documents?: boolean | DocumentFindManyArgs
    loans?: boolean | LoanFindManyArgs
    createdAt?: boolean
    dueDate?: boolean
    signDate?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    _count?: boolean | ContractCountOutputTypeArgs
  }

  export type ContractInclude = {
    borrower?: boolean | BorrowerArgs
    employee?: boolean | EmployeeArgs
    documents?: boolean | DocumentFindManyArgs
    loans?: boolean | LoanFindManyArgs
    _count?: boolean | ContractCountOutputTypeArgs
  }

  export type ContractGetPayload<
    S extends boolean | null | undefined | ContractArgs,
    U = keyof S
      > = S extends true
        ? Contract
    : S extends undefined
    ? never
    : S extends ContractArgs | ContractFindManyArgs
    ?'include' extends U
    ? Contract  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'borrower'
        ? BorrowerGetPayload<S['include'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['include'][P]>>  :
        P extends 'loans'
        ? Array < LoanGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ContractCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Contract ?Contract [P]
  : 
          P extends 'borrower'
        ? BorrowerGetPayload<S['select'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['select'][P]>>  :
        P extends 'loans'
        ? Array < LoanGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ContractCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Contract
  : Contract


  type ContractCountArgs = Merge<
    Omit<ContractFindManyArgs, 'select' | 'include'> & {
      select?: ContractCountAggregateInputType | true
    }
  >

  export interface ContractDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContractFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Contract'> extends True ? CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>> : CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContractFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Contract'> extends True ? CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>> : CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractFindManyArgs>(
      args?: SelectSubset<T, ContractFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Contract>>, PrismaPromise<Array<ContractGetPayload<T>>>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
    **/
    create<T extends ContractCreateArgs>(
      args: SelectSubset<T, ContractCreateArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Create many Contracts.
     *     @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     *     @example
     *     // Create many Contracts
     *     const contract = await prisma.contract.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractCreateManyArgs>(
      args?: SelectSubset<T, ContractCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
    **/
    delete<T extends ContractDeleteArgs>(
      args: SelectSubset<T, ContractDeleteArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractUpdateArgs>(
      args: SelectSubset<T, ContractUpdateArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractDeleteManyArgs>(
      args?: SelectSubset<T, ContractDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractUpdateManyArgs>(
      args: SelectSubset<T, ContractUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
    **/
    upsert<T extends ContractUpsertArgs>(
      args: SelectSubset<T, ContractUpsertArgs>
    ): CheckSelect<T, Prisma__ContractClient<Contract>, Prisma__ContractClient<ContractGetPayload<T>>>

    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContractClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    borrower<T extends BorrowerArgs = {}>(args?: Subset<T, BorrowerArgs>): CheckSelect<T, Prisma__BorrowerClient<Borrower | null >, Prisma__BorrowerClient<BorrowerGetPayload<T> | null >>;

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    documents<T extends DocumentFindManyArgs = {}>(args?: Subset<T, DocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>;

    loans<T extends LoanFindManyArgs = {}>(args?: Subset<T, LoanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loan>>, PrismaPromise<Array<LoanGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Throw an Error if a Contract can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Contract to fetch.
     * 
    **/
    where: ContractWhereUniqueInput
  }


  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Throw an Error if a Contract can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Contract to fetch.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     * 
    **/
    distinct?: Enumerable<ContractScalarFieldEnum>
  }


  /**
   * Contract findMany
   */
  export type ContractFindManyArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter, which Contracts to fetch.
     * 
    **/
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     * 
    **/
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContractScalarFieldEnum>
  }


  /**
   * Contract create
   */
  export type ContractCreateArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The data needed to create a Contract.
     * 
    **/
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }


  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs = {
    data: Enumerable<ContractCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Contract update
   */
  export type ContractUpdateArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The data needed to update a Contract.
     * 
    **/
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     * 
    **/
    where: ContractWhereUniqueInput
  }


  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs = {
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    where?: ContractWhereInput
  }


  /**
   * Contract upsert
   */
  export type ContractUpsertArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * The filter to search for the Contract to update in case it exists.
     * 
    **/
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     * 
    **/
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }


  /**
   * Contract delete
   */
  export type ContractDeleteArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
    /**
     * Filter which Contract to delete.
     * 
    **/
    where: ContractWhereUniqueInput
  }


  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs = {
    where?: ContractWhereInput
  }


  /**
   * Contract without action
   */
  export type ContractArgs = {
    /**
     * Select specific fields to fetch from the Contract
     * 
    **/
    select?: ContractSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ContractInclude | null
  }



  /**
   * Model Loan
   */


  export type AggregateLoan = {
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  export type LoanAvgAggregateOutputType = {
    weeklyPaymentAmount: Decimal | null
    amountToPay: Decimal | null
  }

  export type LoanSumAggregateOutputType = {
    weeklyPaymentAmount: Decimal | null
    amountToPay: Decimal | null
  }

  export type LoanMinAggregateOutputType = {
    id: string | null
    status: LoanState | null
    weeklyPaymentAmount: Decimal | null
    amountToPay: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    contractId: string | null
    loantypeId: string | null
    employeeId: string | null
  }

  export type LoanMaxAggregateOutputType = {
    id: string | null
    status: LoanState | null
    weeklyPaymentAmount: Decimal | null
    amountToPay: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    contractId: string | null
    loantypeId: string | null
    employeeId: string | null
  }

  export type LoanCountAggregateOutputType = {
    id: number
    status: number
    weeklyPaymentAmount: number
    amountToPay: number
    createdAt: number
    updatedAt: number
    contractId: number
    loantypeId: number
    employeeId: number
    _all: number
  }


  export type LoanAvgAggregateInputType = {
    weeklyPaymentAmount?: true
    amountToPay?: true
  }

  export type LoanSumAggregateInputType = {
    weeklyPaymentAmount?: true
    amountToPay?: true
  }

  export type LoanMinAggregateInputType = {
    id?: true
    status?: true
    weeklyPaymentAmount?: true
    amountToPay?: true
    createdAt?: true
    updatedAt?: true
    contractId?: true
    loantypeId?: true
    employeeId?: true
  }

  export type LoanMaxAggregateInputType = {
    id?: true
    status?: true
    weeklyPaymentAmount?: true
    amountToPay?: true
    createdAt?: true
    updatedAt?: true
    contractId?: true
    loantypeId?: true
    employeeId?: true
  }

  export type LoanCountAggregateInputType = {
    id?: true
    status?: true
    weeklyPaymentAmount?: true
    amountToPay?: true
    createdAt?: true
    updatedAt?: true
    contractId?: true
    loantypeId?: true
    employeeId?: true
    _all?: true
  }

  export type LoanAggregateArgs = {
    /**
     * Filter which Loan to aggregate.
     * 
    **/
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanMaxAggregateInputType
  }

  export type GetLoanAggregateType<T extends LoanAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan[P]>
      : GetScalarType<T[P], AggregateLoan[P]>
  }




  export type LoanGroupByArgs = {
    where?: LoanWhereInput
    orderBy?: Enumerable<LoanOrderByWithAggregationInput>
    by: Array<LoanScalarFieldEnum>
    having?: LoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanCountAggregateInputType | true
    _avg?: LoanAvgAggregateInputType
    _sum?: LoanSumAggregateInputType
    _min?: LoanMinAggregateInputType
    _max?: LoanMaxAggregateInputType
  }


  export type LoanGroupByOutputType = {
    id: string
    status: LoanState
    weeklyPaymentAmount: Decimal
    amountToPay: Decimal
    createdAt: Date
    updatedAt: Date
    contractId: string
    loantypeId: string
    employeeId: string
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  type GetLoanGroupByPayload<T extends LoanGroupByArgs> = Promise<
    Array<
      PickArray<LoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanGroupByOutputType[P]>
            : GetScalarType<T[P], LoanGroupByOutputType[P]>
        }
      >
    >


  export type LoanSelect = {
    id?: boolean
    status?: boolean
    payments?: boolean | LoanPaymentFindManyArgs
    weeklyPaymentAmount?: boolean
    amountToPay?: boolean
    loanType?: boolean | LoantypeArgs
    createdAt?: boolean
    employee?: boolean | EmployeeArgs
    updatedAt?: boolean
    contract?: boolean | ContractArgs
    contractId?: boolean
    loantypeId?: boolean
    employeeId?: boolean
    paymentSchedule?: boolean | PaymentScheduleFindManyArgs
    _count?: boolean | LoanCountOutputTypeArgs
  }

  export type LoanInclude = {
    payments?: boolean | LoanPaymentFindManyArgs
    loanType?: boolean | LoantypeArgs
    employee?: boolean | EmployeeArgs
    contract?: boolean | ContractArgs
    paymentSchedule?: boolean | PaymentScheduleFindManyArgs
    _count?: boolean | LoanCountOutputTypeArgs
  }

  export type LoanGetPayload<
    S extends boolean | null | undefined | LoanArgs,
    U = keyof S
      > = S extends true
        ? Loan
    : S extends undefined
    ? never
    : S extends LoanArgs | LoanFindManyArgs
    ?'include' extends U
    ? Loan  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'payments'
        ? Array < LoanPaymentGetPayload<S['include'][P]>>  :
        P extends 'loanType'
        ? LoantypeGetPayload<S['include'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> :
        P extends 'contract'
        ? ContractGetPayload<S['include'][P]> :
        P extends 'paymentSchedule'
        ? Array < PaymentScheduleGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? LoanCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Loan ?Loan [P]
  : 
          P extends 'payments'
        ? Array < LoanPaymentGetPayload<S['select'][P]>>  :
        P extends 'loanType'
        ? LoantypeGetPayload<S['select'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> :
        P extends 'contract'
        ? ContractGetPayload<S['select'][P]> :
        P extends 'paymentSchedule'
        ? Array < PaymentScheduleGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? LoanCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Loan
  : Loan


  type LoanCountArgs = Merge<
    Omit<LoanFindManyArgs, 'select' | 'include'> & {
      select?: LoanCountAggregateInputType | true
    }
  >

  export interface LoanDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Loan that matches the filter.
     * @param {LoanFindUniqueArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Loan'> extends True ? CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>> : CheckSelect<T, Prisma__LoanClient<Loan | null >, Prisma__LoanClient<LoanGetPayload<T> | null >>

    /**
     * Find the first Loan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Loan'> extends True ? CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>> : CheckSelect<T, Prisma__LoanClient<Loan | null >, Prisma__LoanClient<LoanGetPayload<T> | null >>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loan.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanWithIdOnly = await prisma.loan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoanFindManyArgs>(
      args?: SelectSubset<T, LoanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Loan>>, PrismaPromise<Array<LoanGetPayload<T>>>>

    /**
     * Create a Loan.
     * @param {LoanCreateArgs} args - Arguments to create a Loan.
     * @example
     * // Create one Loan
     * const Loan = await prisma.loan.create({
     *   data: {
     *     // ... data to create a Loan
     *   }
     * })
     * 
    **/
    create<T extends LoanCreateArgs>(
      args: SelectSubset<T, LoanCreateArgs>
    ): CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>>

    /**
     * Create many Loans.
     *     @param {LoanCreateManyArgs} args - Arguments to create many Loans.
     *     @example
     *     // Create many Loans
     *     const loan = await prisma.loan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoanCreateManyArgs>(
      args?: SelectSubset<T, LoanCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Loan.
     * @param {LoanDeleteArgs} args - Arguments to delete one Loan.
     * @example
     * // Delete one Loan
     * const Loan = await prisma.loan.delete({
     *   where: {
     *     // ... filter to delete one Loan
     *   }
     * })
     * 
    **/
    delete<T extends LoanDeleteArgs>(
      args: SelectSubset<T, LoanDeleteArgs>
    ): CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>>

    /**
     * Update one Loan.
     * @param {LoanUpdateArgs} args - Arguments to update one Loan.
     * @example
     * // Update one Loan
     * const loan = await prisma.loan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoanUpdateArgs>(
      args: SelectSubset<T, LoanUpdateArgs>
    ): CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>>

    /**
     * Delete zero or more Loans.
     * @param {LoanDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoanDeleteManyArgs>(
      args?: SelectSubset<T, LoanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoanUpdateManyArgs>(
      args: SelectSubset<T, LoanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan.
     * @param {LoanUpsertArgs} args - Arguments to update or create a Loan.
     * @example
     * // Update or create a Loan
     * const loan = await prisma.loan.upsert({
     *   create: {
     *     // ... data to create a Loan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan we want to update
     *   }
     * })
    **/
    upsert<T extends LoanUpsertArgs>(
      args: SelectSubset<T, LoanUpsertArgs>
    ): CheckSelect<T, Prisma__LoanClient<Loan>, Prisma__LoanClient<LoanGetPayload<T>>>

    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loan.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoanCountArgs>(
      args?: Subset<T, LoanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanAggregateArgs>(args: Subset<T, LoanAggregateArgs>): PrismaPromise<GetLoanAggregateType<T>>

    /**
     * Group by Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanGroupByArgs['orderBy'] }
        : { orderBy?: LoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoanClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payments<T extends LoanPaymentFindManyArgs = {}>(args?: Subset<T, LoanPaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LoanPayment>>, PrismaPromise<Array<LoanPaymentGetPayload<T>>>>;

    loanType<T extends LoantypeArgs = {}>(args?: Subset<T, LoantypeArgs>): CheckSelect<T, Prisma__LoantypeClient<Loantype | null >, Prisma__LoantypeClient<LoantypeGetPayload<T> | null >>;

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    contract<T extends ContractArgs = {}>(args?: Subset<T, ContractArgs>): CheckSelect<T, Prisma__ContractClient<Contract | null >, Prisma__ContractClient<ContractGetPayload<T> | null >>;

    paymentSchedule<T extends PaymentScheduleFindManyArgs = {}>(args?: Subset<T, PaymentScheduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PaymentSchedule>>, PrismaPromise<Array<PaymentScheduleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Loan findUnique
   */
  export type LoanFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * Throw an Error if a Loan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Loan to fetch.
     * 
    **/
    where: LoanWhereUniqueInput
  }


  /**
   * Loan findFirst
   */
  export type LoanFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * Throw an Error if a Loan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Loan to fetch.
     * 
    **/
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     * 
    **/
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     * 
    **/
    distinct?: Enumerable<LoanScalarFieldEnum>
  }


  /**
   * Loan findMany
   */
  export type LoanFindManyArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * Filter, which Loans to fetch.
     * 
    **/
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     * 
    **/
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoanScalarFieldEnum>
  }


  /**
   * Loan create
   */
  export type LoanCreateArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * The data needed to create a Loan.
     * 
    **/
    data: XOR<LoanCreateInput, LoanUncheckedCreateInput>
  }


  /**
   * Loan createMany
   */
  export type LoanCreateManyArgs = {
    data: Enumerable<LoanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Loan update
   */
  export type LoanUpdateArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * The data needed to update a Loan.
     * 
    **/
    data: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
    /**
     * Choose, which Loan to update.
     * 
    **/
    where: LoanWhereUniqueInput
  }


  /**
   * Loan updateMany
   */
  export type LoanUpdateManyArgs = {
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    where?: LoanWhereInput
  }


  /**
   * Loan upsert
   */
  export type LoanUpsertArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * The filter to search for the Loan to update in case it exists.
     * 
    **/
    where: LoanWhereUniqueInput
    /**
     * In case the Loan found by the `where` argument doesn't exist, create a new Loan with this data.
     * 
    **/
    create: XOR<LoanCreateInput, LoanUncheckedCreateInput>
    /**
     * In case the Loan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
  }


  /**
   * Loan delete
   */
  export type LoanDeleteArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
    /**
     * Filter which Loan to delete.
     * 
    **/
    where: LoanWhereUniqueInput
  }


  /**
   * Loan deleteMany
   */
  export type LoanDeleteManyArgs = {
    where?: LoanWhereInput
  }


  /**
   * Loan without action
   */
  export type LoanArgs = {
    /**
     * Select specific fields to fetch from the Loan
     * 
    **/
    select?: LoanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanInclude | null
  }



  /**
   * Model LoanPayment
   */


  export type AggregateLoanPayment = {
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  export type LoanPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type LoanPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type LoanPaymentMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    date: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    loanId: string | null
    employeeId: string | null
  }

  export type LoanPaymentMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    date: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    loanId: string | null
    employeeId: string | null
  }

  export type LoanPaymentCountAggregateOutputType = {
    id: number
    amount: number
    date: number
    comments: number
    createdAt: number
    updatedAt: number
    loanId: number
    employeeId: number
    _all: number
  }


  export type LoanPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type LoanPaymentSumAggregateInputType = {
    amount?: true
  }

  export type LoanPaymentMinAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
    employeeId?: true
  }

  export type LoanPaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
    employeeId?: true
  }

  export type LoanPaymentCountAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
    employeeId?: true
    _all?: true
  }

  export type LoanPaymentAggregateArgs = {
    /**
     * Filter which LoanPayment to aggregate.
     * 
    **/
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanPayments
    **/
    _count?: true | LoanPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type GetLoanPaymentAggregateType<T extends LoanPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanPayment[P]>
      : GetScalarType<T[P], AggregateLoanPayment[P]>
  }




  export type LoanPaymentGroupByArgs = {
    where?: LoanPaymentWhereInput
    orderBy?: Enumerable<LoanPaymentOrderByWithAggregationInput>
    by: Array<LoanPaymentScalarFieldEnum>
    having?: LoanPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanPaymentCountAggregateInputType | true
    _avg?: LoanPaymentAvgAggregateInputType
    _sum?: LoanPaymentSumAggregateInputType
    _min?: LoanPaymentMinAggregateInputType
    _max?: LoanPaymentMaxAggregateInputType
  }


  export type LoanPaymentGroupByOutputType = {
    id: string
    amount: Decimal
    date: Date
    comments: string | null
    createdAt: Date
    updatedAt: Date
    loanId: string
    employeeId: string
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  type GetLoanPaymentGroupByPayload<T extends LoanPaymentGroupByArgs> = Promise<
    Array<
      PickArray<LoanPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
        }
      >
    >


  export type LoanPaymentSelect = {
    id?: boolean
    amount?: boolean
    date?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentSchedules?: boolean | PaymentScheduleFindManyArgs
    loan?: boolean | LoanArgs
    loanId?: boolean
    employee?: boolean | EmployeeArgs
    employeeId?: boolean
    _count?: boolean | LoanPaymentCountOutputTypeArgs
  }

  export type LoanPaymentInclude = {
    paymentSchedules?: boolean | PaymentScheduleFindManyArgs
    loan?: boolean | LoanArgs
    employee?: boolean | EmployeeArgs
    _count?: boolean | LoanPaymentCountOutputTypeArgs
  }

  export type LoanPaymentGetPayload<
    S extends boolean | null | undefined | LoanPaymentArgs,
    U = keyof S
      > = S extends true
        ? LoanPayment
    : S extends undefined
    ? never
    : S extends LoanPaymentArgs | LoanPaymentFindManyArgs
    ?'include' extends U
    ? LoanPayment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'paymentSchedules'
        ? Array < PaymentScheduleGetPayload<S['include'][P]>>  :
        P extends 'loan'
        ? LoanGetPayload<S['include'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> :
        P extends '_count'
        ? LoanPaymentCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LoanPayment ?LoanPayment [P]
  : 
          P extends 'paymentSchedules'
        ? Array < PaymentScheduleGetPayload<S['select'][P]>>  :
        P extends 'loan'
        ? LoanGetPayload<S['select'][P]> :
        P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> :
        P extends '_count'
        ? LoanPaymentCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : LoanPayment
  : LoanPayment


  type LoanPaymentCountArgs = Merge<
    Omit<LoanPaymentFindManyArgs, 'select' | 'include'> & {
      select?: LoanPaymentCountAggregateInputType | true
    }
  >

  export interface LoanPaymentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LoanPayment that matches the filter.
     * @param {LoanPaymentFindUniqueArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoanPaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoanPaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoanPayment'> extends True ? CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>> : CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment | null >, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T> | null >>

    /**
     * Find the first LoanPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoanPaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoanPaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoanPayment'> extends True ? CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>> : CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment | null >, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T> | null >>

    /**
     * Find zero or more LoanPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany()
     * 
     * // Get first 10 LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoanPaymentFindManyArgs>(
      args?: SelectSubset<T, LoanPaymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LoanPayment>>, PrismaPromise<Array<LoanPaymentGetPayload<T>>>>

    /**
     * Create a LoanPayment.
     * @param {LoanPaymentCreateArgs} args - Arguments to create a LoanPayment.
     * @example
     * // Create one LoanPayment
     * const LoanPayment = await prisma.loanPayment.create({
     *   data: {
     *     // ... data to create a LoanPayment
     *   }
     * })
     * 
    **/
    create<T extends LoanPaymentCreateArgs>(
      args: SelectSubset<T, LoanPaymentCreateArgs>
    ): CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>>

    /**
     * Create many LoanPayments.
     *     @param {LoanPaymentCreateManyArgs} args - Arguments to create many LoanPayments.
     *     @example
     *     // Create many LoanPayments
     *     const loanPayment = await prisma.loanPayment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoanPaymentCreateManyArgs>(
      args?: SelectSubset<T, LoanPaymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LoanPayment.
     * @param {LoanPaymentDeleteArgs} args - Arguments to delete one LoanPayment.
     * @example
     * // Delete one LoanPayment
     * const LoanPayment = await prisma.loanPayment.delete({
     *   where: {
     *     // ... filter to delete one LoanPayment
     *   }
     * })
     * 
    **/
    delete<T extends LoanPaymentDeleteArgs>(
      args: SelectSubset<T, LoanPaymentDeleteArgs>
    ): CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>>

    /**
     * Update one LoanPayment.
     * @param {LoanPaymentUpdateArgs} args - Arguments to update one LoanPayment.
     * @example
     * // Update one LoanPayment
     * const loanPayment = await prisma.loanPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoanPaymentUpdateArgs>(
      args: SelectSubset<T, LoanPaymentUpdateArgs>
    ): CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>>

    /**
     * Delete zero or more LoanPayments.
     * @param {LoanPaymentDeleteManyArgs} args - Arguments to filter LoanPayments to delete.
     * @example
     * // Delete a few LoanPayments
     * const { count } = await prisma.loanPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoanPaymentDeleteManyArgs>(
      args?: SelectSubset<T, LoanPaymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanPayments
     * const loanPayment = await prisma.loanPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoanPaymentUpdateManyArgs>(
      args: SelectSubset<T, LoanPaymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanPayment.
     * @param {LoanPaymentUpsertArgs} args - Arguments to update or create a LoanPayment.
     * @example
     * // Update or create a LoanPayment
     * const loanPayment = await prisma.loanPayment.upsert({
     *   create: {
     *     // ... data to create a LoanPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanPayment we want to update
     *   }
     * })
    **/
    upsert<T extends LoanPaymentUpsertArgs>(
      args: SelectSubset<T, LoanPaymentUpsertArgs>
    ): CheckSelect<T, Prisma__LoanPaymentClient<LoanPayment>, Prisma__LoanPaymentClient<LoanPaymentGetPayload<T>>>

    /**
     * Count the number of LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentCountArgs} args - Arguments to filter LoanPayments to count.
     * @example
     * // Count the number of LoanPayments
     * const count = await prisma.loanPayment.count({
     *   where: {
     *     // ... the filter for the LoanPayments we want to count
     *   }
     * })
    **/
    count<T extends LoanPaymentCountArgs>(
      args?: Subset<T, LoanPaymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanPaymentAggregateArgs>(args: Subset<T, LoanPaymentAggregateArgs>): PrismaPromise<GetLoanPaymentAggregateType<T>>

    /**
     * Group by LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanPaymentGroupByArgs['orderBy'] }
        : { orderBy?: LoanPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanPaymentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoanPaymentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    paymentSchedules<T extends PaymentScheduleFindManyArgs = {}>(args?: Subset<T, PaymentScheduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PaymentSchedule>>, PrismaPromise<Array<PaymentScheduleGetPayload<T>>>>;

    loan<T extends LoanArgs = {}>(args?: Subset<T, LoanArgs>): CheckSelect<T, Prisma__LoanClient<Loan | null >, Prisma__LoanClient<LoanGetPayload<T> | null >>;

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LoanPayment findUnique
   */
  export type LoanPaymentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * Throw an Error if a LoanPayment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LoanPayment to fetch.
     * 
    **/
    where: LoanPaymentWhereUniqueInput
  }


  /**
   * LoanPayment findFirst
   */
  export type LoanPaymentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * Throw an Error if a LoanPayment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LoanPayment to fetch.
     * 
    **/
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     * 
    **/
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     * 
    **/
    distinct?: Enumerable<LoanPaymentScalarFieldEnum>
  }


  /**
   * LoanPayment findMany
   */
  export type LoanPaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * Filter, which LoanPayments to fetch.
     * 
    **/
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     * 
    **/
    orderBy?: Enumerable<LoanPaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanPayments.
     * 
    **/
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoanPaymentScalarFieldEnum>
  }


  /**
   * LoanPayment create
   */
  export type LoanPaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * The data needed to create a LoanPayment.
     * 
    **/
    data: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
  }


  /**
   * LoanPayment createMany
   */
  export type LoanPaymentCreateManyArgs = {
    data: Enumerable<LoanPaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoanPayment update
   */
  export type LoanPaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * The data needed to update a LoanPayment.
     * 
    **/
    data: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
    /**
     * Choose, which LoanPayment to update.
     * 
    **/
    where: LoanPaymentWhereUniqueInput
  }


  /**
   * LoanPayment updateMany
   */
  export type LoanPaymentUpdateManyArgs = {
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyInput>
    where?: LoanPaymentWhereInput
  }


  /**
   * LoanPayment upsert
   */
  export type LoanPaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * The filter to search for the LoanPayment to update in case it exists.
     * 
    **/
    where: LoanPaymentWhereUniqueInput
    /**
     * In case the LoanPayment found by the `where` argument doesn't exist, create a new LoanPayment with this data.
     * 
    **/
    create: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
    /**
     * In case the LoanPayment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
  }


  /**
   * LoanPayment delete
   */
  export type LoanPaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
    /**
     * Filter which LoanPayment to delete.
     * 
    **/
    where: LoanPaymentWhereUniqueInput
  }


  /**
   * LoanPayment deleteMany
   */
  export type LoanPaymentDeleteManyArgs = {
    where?: LoanPaymentWhereInput
  }


  /**
   * LoanPayment without action
   */
  export type LoanPaymentArgs = {
    /**
     * Select specific fields to fetch from the LoanPayment
     * 
    **/
    select?: LoanPaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoanPaymentInclude | null
  }



  /**
   * Model PaymentSchedule
   */


  export type AggregatePaymentSchedule = {
    _count: PaymentScheduleCountAggregateOutputType | null
    _avg: PaymentScheduleAvgAggregateOutputType | null
    _sum: PaymentScheduleSumAggregateOutputType | null
    _min: PaymentScheduleMinAggregateOutputType | null
    _max: PaymentScheduleMaxAggregateOutputType | null
  }

  export type PaymentScheduleAvgAggregateOutputType = {
    numeration: number | null
    amountToPay: Decimal | null
    paidAmount: Decimal | null
  }

  export type PaymentScheduleSumAggregateOutputType = {
    numeration: number | null
    amountToPay: Decimal | null
    paidAmount: Decimal | null
  }

  export type PaymentScheduleMinAggregateOutputType = {
    id: string | null
    numeration: number | null
    amountToPay: Decimal | null
    paidAmount: Decimal | null
    status: PaymentState | null
    delayed: boolean | null
    dueDate: Date | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    loanId: string | null
  }

  export type PaymentScheduleMaxAggregateOutputType = {
    id: string | null
    numeration: number | null
    amountToPay: Decimal | null
    paidAmount: Decimal | null
    status: PaymentState | null
    delayed: boolean | null
    dueDate: Date | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    loanId: string | null
  }

  export type PaymentScheduleCountAggregateOutputType = {
    id: number
    numeration: number
    amountToPay: number
    paidAmount: number
    status: number
    delayed: number
    dueDate: number
    details: number
    createdAt: number
    updatedAt: number
    loanId: number
    _all: number
  }


  export type PaymentScheduleAvgAggregateInputType = {
    numeration?: true
    amountToPay?: true
    paidAmount?: true
  }

  export type PaymentScheduleSumAggregateInputType = {
    numeration?: true
    amountToPay?: true
    paidAmount?: true
  }

  export type PaymentScheduleMinAggregateInputType = {
    id?: true
    numeration?: true
    amountToPay?: true
    paidAmount?: true
    status?: true
    delayed?: true
    dueDate?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
  }

  export type PaymentScheduleMaxAggregateInputType = {
    id?: true
    numeration?: true
    amountToPay?: true
    paidAmount?: true
    status?: true
    delayed?: true
    dueDate?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
  }

  export type PaymentScheduleCountAggregateInputType = {
    id?: true
    numeration?: true
    amountToPay?: true
    paidAmount?: true
    status?: true
    delayed?: true
    dueDate?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    loanId?: true
    _all?: true
  }

  export type PaymentScheduleAggregateArgs = {
    /**
     * Filter which PaymentSchedule to aggregate.
     * 
    **/
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentSchedules
    **/
    _count?: true | PaymentScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentScheduleMaxAggregateInputType
  }

  export type GetPaymentScheduleAggregateType<T extends PaymentScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentSchedule[P]>
      : GetScalarType<T[P], AggregatePaymentSchedule[P]>
  }




  export type PaymentScheduleGroupByArgs = {
    where?: PaymentScheduleWhereInput
    orderBy?: Enumerable<PaymentScheduleOrderByWithAggregationInput>
    by: Array<PaymentScheduleScalarFieldEnum>
    having?: PaymentScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentScheduleCountAggregateInputType | true
    _avg?: PaymentScheduleAvgAggregateInputType
    _sum?: PaymentScheduleSumAggregateInputType
    _min?: PaymentScheduleMinAggregateInputType
    _max?: PaymentScheduleMaxAggregateInputType
  }


  export type PaymentScheduleGroupByOutputType = {
    id: string
    numeration: number
    amountToPay: Decimal
    paidAmount: Decimal
    status: PaymentState
    delayed: boolean
    dueDate: Date
    details: string | null
    createdAt: Date
    updatedAt: Date
    loanId: string
    _count: PaymentScheduleCountAggregateOutputType | null
    _avg: PaymentScheduleAvgAggregateOutputType | null
    _sum: PaymentScheduleSumAggregateOutputType | null
    _min: PaymentScheduleMinAggregateOutputType | null
    _max: PaymentScheduleMaxAggregateOutputType | null
  }

  type GetPaymentScheduleGroupByPayload<T extends PaymentScheduleGroupByArgs> = Promise<
    Array<
      PickArray<PaymentScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentScheduleGroupByOutputType[P]>
        }
      >
    >


  export type PaymentScheduleSelect = {
    id?: boolean
    numeration?: boolean
    amountToPay?: boolean
    paidAmount?: boolean
    status?: boolean
    delayed?: boolean
    dueDate?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanArgs
    loanId?: boolean
    loanPayments?: boolean | LoanPaymentFindManyArgs
    _count?: boolean | PaymentScheduleCountOutputTypeArgs
  }

  export type PaymentScheduleInclude = {
    loan?: boolean | LoanArgs
    loanPayments?: boolean | LoanPaymentFindManyArgs
    _count?: boolean | PaymentScheduleCountOutputTypeArgs
  }

  export type PaymentScheduleGetPayload<
    S extends boolean | null | undefined | PaymentScheduleArgs,
    U = keyof S
      > = S extends true
        ? PaymentSchedule
    : S extends undefined
    ? never
    : S extends PaymentScheduleArgs | PaymentScheduleFindManyArgs
    ?'include' extends U
    ? PaymentSchedule  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'loan'
        ? LoanGetPayload<S['include'][P]> :
        P extends 'loanPayments'
        ? Array < LoanPaymentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PaymentScheduleCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PaymentSchedule ?PaymentSchedule [P]
  : 
          P extends 'loan'
        ? LoanGetPayload<S['select'][P]> :
        P extends 'loanPayments'
        ? Array < LoanPaymentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PaymentScheduleCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : PaymentSchedule
  : PaymentSchedule


  type PaymentScheduleCountArgs = Merge<
    Omit<PaymentScheduleFindManyArgs, 'select' | 'include'> & {
      select?: PaymentScheduleCountAggregateInputType | true
    }
  >

  export interface PaymentScheduleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PaymentSchedule that matches the filter.
     * @param {PaymentScheduleFindUniqueArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentScheduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentScheduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentSchedule'> extends True ? CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule | null >, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T> | null >>

    /**
     * Find the first PaymentSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleFindFirstArgs} args - Arguments to find a PaymentSchedule
     * @example
     * // Get one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentScheduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentScheduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentSchedule'> extends True ? CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule | null >, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T> | null >>

    /**
     * Find zero or more PaymentSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentSchedules
     * const paymentSchedules = await prisma.paymentSchedule.findMany()
     * 
     * // Get first 10 PaymentSchedules
     * const paymentSchedules = await prisma.paymentSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentScheduleWithIdOnly = await prisma.paymentSchedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentScheduleFindManyArgs>(
      args?: SelectSubset<T, PaymentScheduleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PaymentSchedule>>, PrismaPromise<Array<PaymentScheduleGetPayload<T>>>>

    /**
     * Create a PaymentSchedule.
     * @param {PaymentScheduleCreateArgs} args - Arguments to create a PaymentSchedule.
     * @example
     * // Create one PaymentSchedule
     * const PaymentSchedule = await prisma.paymentSchedule.create({
     *   data: {
     *     // ... data to create a PaymentSchedule
     *   }
     * })
     * 
    **/
    create<T extends PaymentScheduleCreateArgs>(
      args: SelectSubset<T, PaymentScheduleCreateArgs>
    ): CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>>

    /**
     * Create many PaymentSchedules.
     *     @param {PaymentScheduleCreateManyArgs} args - Arguments to create many PaymentSchedules.
     *     @example
     *     // Create many PaymentSchedules
     *     const paymentSchedule = await prisma.paymentSchedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentScheduleCreateManyArgs>(
      args?: SelectSubset<T, PaymentScheduleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentSchedule.
     * @param {PaymentScheduleDeleteArgs} args - Arguments to delete one PaymentSchedule.
     * @example
     * // Delete one PaymentSchedule
     * const PaymentSchedule = await prisma.paymentSchedule.delete({
     *   where: {
     *     // ... filter to delete one PaymentSchedule
     *   }
     * })
     * 
    **/
    delete<T extends PaymentScheduleDeleteArgs>(
      args: SelectSubset<T, PaymentScheduleDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>>

    /**
     * Update one PaymentSchedule.
     * @param {PaymentScheduleUpdateArgs} args - Arguments to update one PaymentSchedule.
     * @example
     * // Update one PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentScheduleUpdateArgs>(
      args: SelectSubset<T, PaymentScheduleUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>>

    /**
     * Delete zero or more PaymentSchedules.
     * @param {PaymentScheduleDeleteManyArgs} args - Arguments to filter PaymentSchedules to delete.
     * @example
     * // Delete a few PaymentSchedules
     * const { count } = await prisma.paymentSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentScheduleDeleteManyArgs>(
      args?: SelectSubset<T, PaymentScheduleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentSchedules
     * const paymentSchedule = await prisma.paymentSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentScheduleUpdateManyArgs>(
      args: SelectSubset<T, PaymentScheduleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentSchedule.
     * @param {PaymentScheduleUpsertArgs} args - Arguments to update or create a PaymentSchedule.
     * @example
     * // Update or create a PaymentSchedule
     * const paymentSchedule = await prisma.paymentSchedule.upsert({
     *   create: {
     *     // ... data to create a PaymentSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentSchedule we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentScheduleUpsertArgs>(
      args: SelectSubset<T, PaymentScheduleUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentScheduleClient<PaymentSchedule>, Prisma__PaymentScheduleClient<PaymentScheduleGetPayload<T>>>

    /**
     * Count the number of PaymentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleCountArgs} args - Arguments to filter PaymentSchedules to count.
     * @example
     * // Count the number of PaymentSchedules
     * const count = await prisma.paymentSchedule.count({
     *   where: {
     *     // ... the filter for the PaymentSchedules we want to count
     *   }
     * })
    **/
    count<T extends PaymentScheduleCountArgs>(
      args?: Subset<T, PaymentScheduleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentScheduleAggregateArgs>(args: Subset<T, PaymentScheduleAggregateArgs>): PrismaPromise<GetPaymentScheduleAggregateType<T>>

    /**
     * Group by PaymentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentScheduleGroupByArgs['orderBy'] }
        : { orderBy?: PaymentScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentScheduleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentScheduleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    loan<T extends LoanArgs = {}>(args?: Subset<T, LoanArgs>): CheckSelect<T, Prisma__LoanClient<Loan | null >, Prisma__LoanClient<LoanGetPayload<T> | null >>;

    loanPayments<T extends LoanPaymentFindManyArgs = {}>(args?: Subset<T, LoanPaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LoanPayment>>, PrismaPromise<Array<LoanPaymentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PaymentSchedule findUnique
   */
  export type PaymentScheduleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * Throw an Error if a PaymentSchedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PaymentSchedule to fetch.
     * 
    **/
    where: PaymentScheduleWhereUniqueInput
  }


  /**
   * PaymentSchedule findFirst
   */
  export type PaymentScheduleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * Throw an Error if a PaymentSchedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PaymentSchedule to fetch.
     * 
    **/
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSchedules.
     * 
    **/
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSchedules.
     * 
    **/
    distinct?: Enumerable<PaymentScheduleScalarFieldEnum>
  }


  /**
   * PaymentSchedule findMany
   */
  export type PaymentScheduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * Filter, which PaymentSchedules to fetch.
     * 
    **/
    where?: PaymentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSchedules to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentSchedules.
     * 
    **/
    cursor?: PaymentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSchedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSchedules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScheduleScalarFieldEnum>
  }


  /**
   * PaymentSchedule create
   */
  export type PaymentScheduleCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * The data needed to create a PaymentSchedule.
     * 
    **/
    data: XOR<PaymentScheduleCreateInput, PaymentScheduleUncheckedCreateInput>
  }


  /**
   * PaymentSchedule createMany
   */
  export type PaymentScheduleCreateManyArgs = {
    data: Enumerable<PaymentScheduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PaymentSchedule update
   */
  export type PaymentScheduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * The data needed to update a PaymentSchedule.
     * 
    **/
    data: XOR<PaymentScheduleUpdateInput, PaymentScheduleUncheckedUpdateInput>
    /**
     * Choose, which PaymentSchedule to update.
     * 
    **/
    where: PaymentScheduleWhereUniqueInput
  }


  /**
   * PaymentSchedule updateMany
   */
  export type PaymentScheduleUpdateManyArgs = {
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyInput>
    where?: PaymentScheduleWhereInput
  }


  /**
   * PaymentSchedule upsert
   */
  export type PaymentScheduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * The filter to search for the PaymentSchedule to update in case it exists.
     * 
    **/
    where: PaymentScheduleWhereUniqueInput
    /**
     * In case the PaymentSchedule found by the `where` argument doesn't exist, create a new PaymentSchedule with this data.
     * 
    **/
    create: XOR<PaymentScheduleCreateInput, PaymentScheduleUncheckedCreateInput>
    /**
     * In case the PaymentSchedule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentScheduleUpdateInput, PaymentScheduleUncheckedUpdateInput>
  }


  /**
   * PaymentSchedule delete
   */
  export type PaymentScheduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
    /**
     * Filter which PaymentSchedule to delete.
     * 
    **/
    where: PaymentScheduleWhereUniqueInput
  }


  /**
   * PaymentSchedule deleteMany
   */
  export type PaymentScheduleDeleteManyArgs = {
    where?: PaymentScheduleWhereInput
  }


  /**
   * PaymentSchedule without action
   */
  export type PaymentScheduleArgs = {
    /**
     * Select specific fields to fetch from the PaymentSchedule
     * 
    **/
    select?: PaymentScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentScheduleInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const LogScalarFieldEnum: {
    id: 'id',
    requestBody: 'requestBody',
    requestType: 'requestType',
    deviceType: 'deviceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    systemSectionId: 'systemSectionId'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const SystemSectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSectionScalarFieldEnum = (typeof SystemSectionScalarFieldEnum)[keyof typeof SystemSectionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    lastLogin: 'lastLogin',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    borrowerId: 'borrowerId',
    avalId: 'avalId',
    contractId: 'contractId',
    employeeId: 'employeeId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const AvalScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvalScalarFieldEnum = (typeof AvalScalarFieldEnum)[keyof typeof AvalScalarFieldEnum]


  export const BorrowerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BorrowerScalarFieldEnum = (typeof BorrowerScalarFieldEnum)[keyof typeof BorrowerScalarFieldEnum]


  export const LocalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    borrowerId: 'borrowerId'
  };

  export type LocalScalarFieldEnum = (typeof LocalScalarFieldEnum)[keyof typeof LocalScalarFieldEnum]


  export const PhoneScalarFieldEnum: {
    id: 'id',
    number: 'number',
    borrowerId: 'borrowerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avalId: 'avalId',
    employeeId: 'employeeId'
  };

  export type PhoneScalarFieldEnum = (typeof PhoneScalarFieldEnum)[keyof typeof PhoneScalarFieldEnum]


  export const ContractTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    monthDuration: 'monthDuration',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractTypeScalarFieldEnum = (typeof ContractTypeScalarFieldEnum)[keyof typeof ContractTypeScalarFieldEnum]


  export const LoantypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weekDuration: 'weekDuration',
    rate: 'rate',
    overdueRate: 'overdueRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoantypeScalarFieldEnum = (typeof LoantypeScalarFieldEnum)[keyof typeof LoantypeScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    borrowerId: 'borrowerId',
    createdAt: 'createdAt',
    dueDate: 'dueDate',
    signDate: 'signDate',
    updatedAt: 'updatedAt',
    employeeId: 'employeeId'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const LoanScalarFieldEnum: {
    id: 'id',
    status: 'status',
    weeklyPaymentAmount: 'weeklyPaymentAmount',
    amountToPay: 'amountToPay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contractId: 'contractId',
    loantypeId: 'loantypeId',
    employeeId: 'employeeId'
  };

  export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


  export const LoanPaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    date: 'date',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    loanId: 'loanId',
    employeeId: 'employeeId'
  };

  export type LoanPaymentScalarFieldEnum = (typeof LoanPaymentScalarFieldEnum)[keyof typeof LoanPaymentScalarFieldEnum]


  export const PaymentScheduleScalarFieldEnum: {
    id: 'id',
    numeration: 'numeration',
    amountToPay: 'amountToPay',
    paidAmount: 'paidAmount',
    status: 'status',
    delayed: 'delayed',
    dueDate: 'dueDate',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    loanId: 'loanId'
  };

  export type PaymentScheduleScalarFieldEnum = (typeof PaymentScheduleScalarFieldEnum)[keyof typeof PaymentScheduleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type LogWhereInput = {
    AND?: Enumerable<LogWhereInput>
    OR?: Enumerable<LogWhereInput>
    NOT?: Enumerable<LogWhereInput>
    id?: StringFilter | string
    section?: XOR<SystemSectionRelationFilter, SystemSectionWhereInput>
    requestBody?: StringFilter | string
    requestType?: StringFilter | string
    deviceType?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    systemSectionId?: StringFilter | string
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    section?: SystemSectionOrderByWithRelationInput
    requestBody?: SortOrder
    requestType?: SortOrder
    deviceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemSectionId?: SortOrder
  }

  export type LogWhereUniqueInput = {
    id?: string
  }

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    requestBody?: SortOrder
    requestType?: SortOrder
    deviceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemSectionId?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LogScalarWhereWithAggregatesInput>
    OR?: Enumerable<LogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LogScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    requestBody?: StringWithAggregatesFilter | string
    requestType?: StringWithAggregatesFilter | string
    deviceType?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    systemSectionId?: StringWithAggregatesFilter | string
  }

  export type SystemSectionWhereInput = {
    AND?: Enumerable<SystemSectionWhereInput>
    OR?: Enumerable<SystemSectionWhereInput>
    NOT?: Enumerable<SystemSectionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    logs?: LogListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SystemSectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logs?: LogOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSectionWhereUniqueInput = {
    id?: string
  }

  export type SystemSectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSectionCountOrderByAggregateInput
    _max?: SystemSectionMaxOrderByAggregateInput
    _min?: SystemSectionMinOrderByAggregateInput
  }

  export type SystemSectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SystemSectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SystemSectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SystemSectionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    fullName?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    lastLogin?: DateTimeNullableFilter | Date | string | null
    profilePicture?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Employee?: EmployeeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Employee?: EmployeeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    lastLogin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    profilePicture?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: Enumerable<EmployeeWhereInput>
    OR?: Enumerable<EmployeeWhereInput>
    NOT?: Enumerable<EmployeeWhereInput>
    id?: StringFilter | string
    type?: EnumEmployeesTypesFilter | EmployeesTypes
    phones?: PhoneListRelationFilter
    documents?: DocumentListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    contracts?: ContractListRelationFilter
    loan?: LoanListRelationFilter
    userId?: StringFilter | string
    loanPayment?: LoanPaymentListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    phones?: PhoneOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    loan?: LoanOrderByRelationAggregateInput
    userId?: SortOrder
    loanPayment?: LoanPaymentOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumEmployeesTypesWithAggregatesFilter | EmployeesTypes
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    type?: EnumDocumentTypeFilter | DocumentType
    Borrower?: XOR<BorrowerRelationFilter, BorrowerWhereInput> | null
    borrowerId?: StringNullableFilter | string | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    aval?: XOR<AvalRelationFilter, AvalWhereInput> | null
    avalId?: StringNullableFilter | string | null
    Contract?: XOR<ContractRelationFilter, ContractWhereInput> | null
    contractId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    Borrower?: BorrowerOrderByWithRelationInput
    borrowerId?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    aval?: AvalOrderByWithRelationInput
    avalId?: SortOrder
    Contract?: ContractOrderByWithRelationInput
    contractId?: SortOrder
    employeeId?: SortOrder
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    borrowerId?: SortOrder
    avalId?: SortOrder
    contractId?: SortOrder
    employeeId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumDocumentTypeWithAggregatesFilter | DocumentType
    borrowerId?: StringNullableWithAggregatesFilter | string | null
    avalId?: StringNullableWithAggregatesFilter | string | null
    contractId?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    logo?: StringFilter | string
    url?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerWhereUniqueInput = {
    id?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    logo?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AvalWhereInput = {
    AND?: Enumerable<AvalWhereInput>
    OR?: Enumerable<AvalWhereInput>
    NOT?: Enumerable<AvalWhereInput>
    id?: StringFilter | string
    phones?: PhoneListRelationFilter
    email?: StringFilter | string
    fullName?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    documents?: DocumentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AvalOrderByWithRelationInput = {
    id?: SortOrder
    phones?: PhoneOrderByRelationAggregateInput
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documents?: DocumentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvalWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type AvalOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvalCountOrderByAggregateInput
    _max?: AvalMaxOrderByAggregateInput
    _min?: AvalMinOrderByAggregateInput
  }

  export type AvalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AvalScalarWhereWithAggregatesInput>
    OR?: Enumerable<AvalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AvalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BorrowerWhereInput = {
    AND?: Enumerable<BorrowerWhereInput>
    OR?: Enumerable<BorrowerWhereInput>
    NOT?: Enumerable<BorrowerWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    email?: StringNullableFilter | string | null
    phones?: PhoneListRelationFilter
    documents?: DocumentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Contract?: ContractListRelationFilter
    Local?: LocalListRelationFilter
  }

  export type BorrowerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    phones?: PhoneOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Contract?: ContractOrderByRelationAggregateInput
    Local?: LocalOrderByRelationAggregateInput
  }

  export type BorrowerWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type BorrowerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BorrowerCountOrderByAggregateInput
    _max?: BorrowerMaxOrderByAggregateInput
    _min?: BorrowerMinOrderByAggregateInput
  }

  export type BorrowerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BorrowerScalarWhereWithAggregatesInput>
    OR?: Enumerable<BorrowerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BorrowerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LocalWhereInput = {
    AND?: Enumerable<LocalWhereInput>
    OR?: Enumerable<LocalWhereInput>
    NOT?: Enumerable<LocalWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    borrower?: XOR<BorrowerRelationFilter, BorrowerWhereInput>
    borrowerId?: StringFilter | string
  }

  export type LocalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrower?: BorrowerOrderByWithRelationInput
    borrowerId?: SortOrder
  }

  export type LocalWhereUniqueInput = {
    id?: string
  }

  export type LocalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrowerId?: SortOrder
    _count?: LocalCountOrderByAggregateInput
    _max?: LocalMaxOrderByAggregateInput
    _min?: LocalMinOrderByAggregateInput
  }

  export type LocalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LocalScalarWhereWithAggregatesInput>
    OR?: Enumerable<LocalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LocalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    borrowerId?: StringWithAggregatesFilter | string
  }

  export type PhoneWhereInput = {
    AND?: Enumerable<PhoneWhereInput>
    OR?: Enumerable<PhoneWhereInput>
    NOT?: Enumerable<PhoneWhereInput>
    id?: StringFilter | string
    number?: StringFilter | string
    Borrower?: XOR<BorrowerRelationFilter, BorrowerWhereInput> | null
    borrowerId?: StringNullableFilter | string | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    aval?: XOR<AvalRelationFilter, AvalWhereInput> | null
    avalId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
  }

  export type PhoneOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    Borrower?: BorrowerOrderByWithRelationInput
    borrowerId?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aval?: AvalOrderByWithRelationInput
    avalId?: SortOrder
    employeeId?: SortOrder
  }

  export type PhoneWhereUniqueInput = {
    id?: string
    number?: string
  }

  export type PhoneOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avalId?: SortOrder
    employeeId?: SortOrder
    _count?: PhoneCountOrderByAggregateInput
    _max?: PhoneMaxOrderByAggregateInput
    _min?: PhoneMinOrderByAggregateInput
  }

  export type PhoneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    borrowerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    avalId?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ContractTypeWhereInput = {
    AND?: Enumerable<ContractTypeWhereInput>
    OR?: Enumerable<ContractTypeWhereInput>
    NOT?: Enumerable<ContractTypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    monthDuration?: IntFilter | number
    amount?: DecimalFilter | Decimal | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ContractTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    monthDuration?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractTypeWhereUniqueInput = {
    id?: string
  }

  export type ContractTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    monthDuration?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractTypeCountOrderByAggregateInput
    _avg?: ContractTypeAvgOrderByAggregateInput
    _max?: ContractTypeMaxOrderByAggregateInput
    _min?: ContractTypeMinOrderByAggregateInput
    _sum?: ContractTypeSumOrderByAggregateInput
  }

  export type ContractTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContractTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContractTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContractTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    monthDuration?: IntWithAggregatesFilter | number
    amount?: DecimalWithAggregatesFilter | Decimal | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type LoantypeWhereInput = {
    AND?: Enumerable<LoantypeWhereInput>
    OR?: Enumerable<LoantypeWhereInput>
    NOT?: Enumerable<LoantypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    weekDuration?: IntFilter | number
    rate?: FloatFilter | number
    overdueRate?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Loan?: LoanListRelationFilter
  }

  export type LoantypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Loan?: LoanOrderByRelationAggregateInput
  }

  export type LoantypeWhereUniqueInput = {
    id?: string
  }

  export type LoantypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoantypeCountOrderByAggregateInput
    _avg?: LoantypeAvgOrderByAggregateInput
    _max?: LoantypeMaxOrderByAggregateInput
    _min?: LoantypeMinOrderByAggregateInput
    _sum?: LoantypeSumOrderByAggregateInput
  }

  export type LoantypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoantypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoantypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoantypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    weekDuration?: IntWithAggregatesFilter | number
    rate?: FloatWithAggregatesFilter | number
    overdueRate?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ContractWhereInput = {
    AND?: Enumerable<ContractWhereInput>
    OR?: Enumerable<ContractWhereInput>
    NOT?: Enumerable<ContractWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | number | string
    borrower?: XOR<BorrowerRelationFilter, BorrowerWhereInput>
    borrowerId?: StringFilter | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    documents?: DocumentListRelationFilter
    loans?: LoanListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    dueDate?: DateTimeFilter | Date | string
    signDate?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    employeeId?: StringFilter | string
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    borrower?: BorrowerOrderByWithRelationInput
    borrowerId?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    loans?: LoanOrderByRelationAggregateInput
    createdAt?: SortOrder
    dueDate?: SortOrder
    signDate?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type ContractWhereUniqueInput = {
    id?: string
  }

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    dueDate?: SortOrder
    signDate?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContractScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContractScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContractScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | number | string
    borrowerId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    dueDate?: DateTimeWithAggregatesFilter | Date | string
    signDate?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    employeeId?: StringWithAggregatesFilter | string
  }

  export type LoanWhereInput = {
    AND?: Enumerable<LoanWhereInput>
    OR?: Enumerable<LoanWhereInput>
    NOT?: Enumerable<LoanWhereInput>
    id?: StringFilter | string
    status?: EnumLoanStateFilter | LoanState
    payments?: LoanPaymentListRelationFilter
    weeklyPaymentAmount?: DecimalFilter | Decimal | number | string
    amountToPay?: DecimalFilter | Decimal | number | string
    loanType?: XOR<LoantypeRelationFilter, LoantypeWhereInput>
    createdAt?: DateTimeFilter | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    updatedAt?: DateTimeFilter | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    contractId?: StringFilter | string
    loantypeId?: StringFilter | string
    employeeId?: StringFilter | string
    paymentSchedule?: PaymentScheduleListRelationFilter
  }

  export type LoanOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    payments?: LoanPaymentOrderByRelationAggregateInput
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
    loanType?: LoantypeOrderByWithRelationInput
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    contractId?: SortOrder
    loantypeId?: SortOrder
    employeeId?: SortOrder
    paymentSchedule?: PaymentScheduleOrderByRelationAggregateInput
  }

  export type LoanWhereUniqueInput = {
    id?: string
  }

  export type LoanOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractId?: SortOrder
    loantypeId?: SortOrder
    employeeId?: SortOrder
    _count?: LoanCountOrderByAggregateInput
    _avg?: LoanAvgOrderByAggregateInput
    _max?: LoanMaxOrderByAggregateInput
    _min?: LoanMinOrderByAggregateInput
    _sum?: LoanSumOrderByAggregateInput
  }

  export type LoanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoanScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumLoanStateWithAggregatesFilter | LoanState
    weeklyPaymentAmount?: DecimalWithAggregatesFilter | Decimal | number | string
    amountToPay?: DecimalWithAggregatesFilter | Decimal | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    contractId?: StringWithAggregatesFilter | string
    loantypeId?: StringWithAggregatesFilter | string
    employeeId?: StringWithAggregatesFilter | string
  }

  export type LoanPaymentWhereInput = {
    AND?: Enumerable<LoanPaymentWhereInput>
    OR?: Enumerable<LoanPaymentWhereInput>
    NOT?: Enumerable<LoanPaymentWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | number | string
    date?: DateTimeFilter | Date | string
    comments?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    paymentSchedules?: PaymentScheduleListRelationFilter
    loan?: XOR<LoanRelationFilter, LoanWhereInput>
    loanId?: StringFilter | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    employeeId?: StringFilter | string
  }

  export type LoanPaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentSchedules?: PaymentScheduleOrderByRelationAggregateInput
    loan?: LoanOrderByWithRelationInput
    loanId?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    employeeId?: SortOrder
  }

  export type LoanPaymentWhereUniqueInput = {
    id?: string
  }

  export type LoanPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
    employeeId?: SortOrder
    _count?: LoanPaymentCountOrderByAggregateInput
    _avg?: LoanPaymentAvgOrderByAggregateInput
    _max?: LoanPaymentMaxOrderByAggregateInput
    _min?: LoanPaymentMinOrderByAggregateInput
    _sum?: LoanPaymentSumOrderByAggregateInput
  }

  export type LoanPaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoanPaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoanPaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoanPaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | number | string
    date?: DateTimeWithAggregatesFilter | Date | string
    comments?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    loanId?: StringWithAggregatesFilter | string
    employeeId?: StringWithAggregatesFilter | string
  }

  export type PaymentScheduleWhereInput = {
    AND?: Enumerable<PaymentScheduleWhereInput>
    OR?: Enumerable<PaymentScheduleWhereInput>
    NOT?: Enumerable<PaymentScheduleWhereInput>
    id?: StringFilter | string
    numeration?: IntFilter | number
    amountToPay?: DecimalFilter | Decimal | number | string
    paidAmount?: DecimalFilter | Decimal | number | string
    status?: EnumPaymentStateFilter | PaymentState
    delayed?: BoolFilter | boolean
    dueDate?: DateTimeFilter | Date | string
    details?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    loan?: XOR<LoanRelationFilter, LoanWhereInput>
    loanId?: StringFilter | string
    loanPayments?: LoanPaymentListRelationFilter
  }

  export type PaymentScheduleOrderByWithRelationInput = {
    id?: SortOrder
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    delayed?: SortOrder
    dueDate?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanOrderByWithRelationInput
    loanId?: SortOrder
    loanPayments?: LoanPaymentOrderByRelationAggregateInput
  }

  export type PaymentScheduleWhereUniqueInput = {
    id?: string
  }

  export type PaymentScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    delayed?: SortOrder
    dueDate?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
    _count?: PaymentScheduleCountOrderByAggregateInput
    _avg?: PaymentScheduleAvgOrderByAggregateInput
    _max?: PaymentScheduleMaxOrderByAggregateInput
    _min?: PaymentScheduleMinOrderByAggregateInput
    _sum?: PaymentScheduleSumOrderByAggregateInput
  }

  export type PaymentScheduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScheduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScheduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScheduleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    numeration?: IntWithAggregatesFilter | number
    amountToPay?: DecimalWithAggregatesFilter | Decimal | number | string
    paidAmount?: DecimalWithAggregatesFilter | Decimal | number | string
    status?: EnumPaymentStateWithAggregatesFilter | PaymentState
    delayed?: BoolWithAggregatesFilter | boolean
    dueDate?: DateTimeWithAggregatesFilter | Date | string
    details?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    loanId?: StringWithAggregatesFilter | string
  }

  export type LogCreateInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    section: SystemSectionCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemSectionId: string
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SystemSectionUpdateOneRequiredWithoutLogsInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemSectionId?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateManyInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemSectionId: string
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemSectionId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemSectionCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogCreateNestedManyWithoutSectionInput
  }

  export type SystemSectionUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SystemSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUpdateManyWithoutSectionInput
  }

  export type SystemSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutSectionInput
  }

  export type SystemSectionCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin?: Date | string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin?: Date | string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin?: Date | string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    documents?: DocumentUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    type: DocumentType
    Borrower?: BorrowerCreateNestedOneWithoutDocumentsInput
    Employee?: EmployeeCreateNestedOneWithoutDocumentsInput
    aval?: AvalCreateNestedOneWithoutDocumentsInput
    Contract?: ContractCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    Borrower?: BorrowerUpdateOneWithoutDocumentsInput
    Employee?: EmployeeUpdateOneWithoutDocumentsInput
    aval?: AvalUpdateOneWithoutDocumentsInput
    Contract?: ContractUpdateOneWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    logo: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    logo: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    logo: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvalCreateInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutAvalInput
    documents?: DocumentCreateNestedManyWithoutAvalInput
  }

  export type AvalUncheckedCreateInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutAvalInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAvalInput
  }

  export type AvalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutAvalInput
    documents?: DocumentUpdateManyWithoutAvalInput
  }

  export type AvalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutAvalInput
    documents?: DocumentUncheckedUpdateManyWithoutAvalInput
  }

  export type AvalCreateManyInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowerCreateInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutBorrowerInput
    documents?: DocumentCreateNestedManyWithoutBorrowerInput
    Contract?: ContractCreateNestedManyWithoutBorrowerInput
    Local?: LocalCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutBorrowerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutBorrowerInput
    Contract?: ContractUncheckedCreateNestedManyWithoutBorrowerInput
    Local?: LocalUncheckedCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutBorrowerInput
    documents?: DocumentUpdateManyWithoutBorrowerInput
    Contract?: ContractUpdateManyWithoutBorrowerInput
    Local?: LocalUpdateManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutBorrowerInput
    documents?: DocumentUncheckedUpdateManyWithoutBorrowerInput
    Contract?: ContractUncheckedUpdateManyWithoutBorrowerInput
    Local?: LocalUncheckedUpdateManyWithoutBorrowerInput
  }

  export type BorrowerCreateManyInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalCreateInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: BorrowerCreateNestedOneWithoutLocalInput
  }

  export type LocalUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowerId: string
  }

  export type LocalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: BorrowerUpdateOneRequiredWithoutLocalInput
  }

  export type LocalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
  }

  export type LocalCreateManyInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowerId: string
  }

  export type LocalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneCreateInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Borrower?: BorrowerCreateNestedOneWithoutPhonesInput
    Employee?: EmployeeCreateNestedOneWithoutPhonesInput
    aval?: AvalCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
    employeeId?: string | null
  }

  export type PhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Borrower?: BorrowerUpdateOneWithoutPhonesInput
    Employee?: EmployeeUpdateOneWithoutPhonesInput
    aval?: AvalUpdateOneWithoutPhonesInput
  }

  export type PhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneCreateManyInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
    employeeId?: string | null
  }

  export type PhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractTypeCreateInput = {
    id?: string
    name: string
    monthDuration: number
    amount: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ContractTypeUncheckedCreateInput = {
    id?: string
    name: string
    monthDuration: number
    amount: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ContractTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthDuration?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthDuration?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractTypeCreateManyInput = {
    id?: string
    name: string
    monthDuration: number
    amount: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ContractTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthDuration?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthDuration?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LoantypeCreateInput = {
    id?: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Loan?: LoanCreateNestedManyWithoutLoanTypeInput
  }

  export type LoantypeUncheckedCreateInput = {
    id?: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Loan?: LoanUncheckedCreateNestedManyWithoutLoanTypeInput
  }

  export type LoantypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Loan?: LoanUpdateManyWithoutLoanTypeInput
  }

  export type LoantypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Loan?: LoanUncheckedUpdateManyWithoutLoanTypeInput
  }

  export type LoantypeCreateManyInput = {
    id?: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoantypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoantypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    borrower: BorrowerCreateNestedOneWithoutContractInput
    employee?: EmployeeCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    loans?: LoanCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    loans?: LoanUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: BorrowerUpdateOneRequiredWithoutContractInput
    employee?: EmployeeUpdateOneWithoutContractsInput
    documents?: DocumentUpdateManyWithoutContractInput
    loans?: LoanUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutContractInput
    loans?: LoanUncheckedUpdateManyWithoutContractInput
  }

  export type ContractCreateManyInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanCreateInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
    loanType: LoantypeCreateNestedOneWithoutLoanInput
    employee: EmployeeCreateNestedOneWithoutLoanInput
    contract: ContractCreateNestedOneWithoutLoansInput
    paymentSchedule?: PaymentScheduleCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
    employeeId: string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanInput
    loanType?: LoantypeUpdateOneRequiredWithoutLoanInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanInput
    contract?: ContractUpdateOneRequiredWithoutLoansInput
    paymentSchedule?: PaymentScheduleUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutLoanInput
  }

  export type LoanCreateManyInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
    employeeId: string
  }

  export type LoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentCreateInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput
    loan: LoanCreateNestedOneWithoutPaymentsInput
    employee: EmployeeCreateNestedOneWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedCreateInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
    employeeId: string
  }

  export type LoanPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentSchedules?: PaymentScheduleUpdateManyWithoutLoanPaymentsInput
    loan?: LoanUpdateOneRequiredWithoutPaymentsInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentCreateManyInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
    employeeId: string
  }

  export type LoanPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentScheduleCreateInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutPaymentScheduleInput
    loanPayments?: LoanPaymentCreateNestedManyWithoutPaymentSchedulesInput
  }

  export type PaymentScheduleUncheckedCreateInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
  }

  export type PaymentScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutPaymentScheduleInput
    loanPayments?: LoanPaymentUpdateManyWithoutPaymentSchedulesInput
  }

  export type PaymentScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentScheduleCreateManyInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
  }

  export type PaymentScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type SystemSectionRelationFilter = {
    is?: SystemSectionWhereInput
    isNot?: SystemSectionWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    requestBody?: SortOrder
    requestType?: SortOrder
    deviceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemSectionId?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    requestBody?: SortOrder
    requestType?: SortOrder
    deviceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemSectionId?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    requestBody?: SortOrder
    requestType?: SortOrder
    deviceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemSectionId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemSectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumEmployeesTypesFilter = {
    equals?: EmployeesTypes
    in?: Enumerable<EmployeesTypes>
    notIn?: Enumerable<EmployeesTypes>
    not?: NestedEnumEmployeesTypesFilter | EmployeesTypes
  }

  export type PhoneListRelationFilter = {
    every?: PhoneWhereInput
    some?: PhoneWhereInput
    none?: PhoneWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type LoanListRelationFilter = {
    every?: LoanWhereInput
    some?: LoanWhereInput
    none?: LoanWhereInput
  }

  export type LoanPaymentListRelationFilter = {
    every?: LoanPaymentWhereInput
    some?: LoanPaymentWhereInput
    none?: LoanPaymentWhereInput
  }

  export type PhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumEmployeesTypesWithAggregatesFilter = {
    equals?: EmployeesTypes
    in?: Enumerable<EmployeesTypes>
    notIn?: Enumerable<EmployeesTypes>
    not?: NestedEnumEmployeesTypesWithAggregatesFilter | EmployeesTypes
    _count?: NestedIntFilter
    _min?: NestedEnumEmployeesTypesFilter
    _max?: NestedEnumEmployeesTypesFilter
  }

  export type EnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type BorrowerRelationFilter = {
    is?: BorrowerWhereInput | null
    isNot?: BorrowerWhereInput | null
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type AvalRelationFilter = {
    is?: AvalWhereInput | null
    isNot?: AvalWhereInput | null
  }

  export type ContractRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    borrowerId?: SortOrder
    avalId?: SortOrder
    contractId?: SortOrder
    employeeId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    borrowerId?: SortOrder
    avalId?: SortOrder
    contractId?: SortOrder
    employeeId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    borrowerId?: SortOrder
    avalId?: SortOrder
    contractId?: SortOrder
    employeeId?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvalCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvalMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvalMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalListRelationFilter = {
    every?: LocalWhereInput
    some?: LocalWhereInput
    none?: LocalWhereInput
  }

  export type LocalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorrowerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrowerId?: SortOrder
  }

  export type LocalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrowerId?: SortOrder
  }

  export type LocalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrowerId?: SortOrder
  }

  export type PhoneCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avalId?: SortOrder
    employeeId?: SortOrder
  }

  export type PhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avalId?: SortOrder
    employeeId?: SortOrder
  }

  export type PhoneMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avalId?: SortOrder
    employeeId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type ContractTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthDuration?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractTypeAvgOrderByAggregateInput = {
    monthDuration?: SortOrder
    amount?: SortOrder
  }

  export type ContractTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthDuration?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthDuration?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractTypeSumOrderByAggregateInput = {
    monthDuration?: SortOrder
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type LoantypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoantypeAvgOrderByAggregateInput = {
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
  }

  export type LoantypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoantypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoantypeSumOrderByAggregateInput = {
    weekDuration?: SortOrder
    rate?: SortOrder
    overdueRate?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    dueDate?: SortOrder
    signDate?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    dueDate?: SortOrder
    signDate?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    borrowerId?: SortOrder
    createdAt?: SortOrder
    dueDate?: SortOrder
    signDate?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumLoanStateFilter = {
    equals?: LoanState
    in?: Enumerable<LoanState>
    notIn?: Enumerable<LoanState>
    not?: NestedEnumLoanStateFilter | LoanState
  }

  export type LoantypeRelationFilter = {
    is?: LoantypeWhereInput
    isNot?: LoantypeWhereInput
  }

  export type PaymentScheduleListRelationFilter = {
    every?: PaymentScheduleWhereInput
    some?: PaymentScheduleWhereInput
    none?: PaymentScheduleWhereInput
  }

  export type PaymentScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractId?: SortOrder
    loantypeId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanAvgOrderByAggregateInput = {
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
  }

  export type LoanMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractId?: SortOrder
    loantypeId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contractId?: SortOrder
    loantypeId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanSumOrderByAggregateInput = {
    weeklyPaymentAmount?: SortOrder
    amountToPay?: SortOrder
  }

  export type EnumLoanStateWithAggregatesFilter = {
    equals?: LoanState
    in?: Enumerable<LoanState>
    notIn?: Enumerable<LoanState>
    not?: NestedEnumLoanStateWithAggregatesFilter | LoanState
    _count?: NestedIntFilter
    _min?: NestedEnumLoanStateFilter
    _max?: NestedEnumLoanStateFilter
  }

  export type LoanRelationFilter = {
    is?: LoanWhereInput
    isNot?: LoanWhereInput
  }

  export type LoanPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type LoanPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
    employeeId?: SortOrder
  }

  export type LoanPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStateFilter = {
    equals?: PaymentState
    in?: Enumerable<PaymentState>
    notIn?: Enumerable<PaymentState>
    not?: NestedEnumPaymentStateFilter | PaymentState
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type PaymentScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    delayed?: SortOrder
    dueDate?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
  }

  export type PaymentScheduleAvgOrderByAggregateInput = {
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
  }

  export type PaymentScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    delayed?: SortOrder
    dueDate?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
  }

  export type PaymentScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    delayed?: SortOrder
    dueDate?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanId?: SortOrder
  }

  export type PaymentScheduleSumOrderByAggregateInput = {
    numeration?: SortOrder
    amountToPay?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumPaymentStateWithAggregatesFilter = {
    equals?: PaymentState
    in?: Enumerable<PaymentState>
    notIn?: Enumerable<PaymentState>
    not?: NestedEnumPaymentStateWithAggregatesFilter | PaymentState
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStateFilter
    _max?: NestedEnumPaymentStateFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SystemSectionCreateNestedOneWithoutLogsInput = {
    create?: XOR<SystemSectionCreateWithoutLogsInput, SystemSectionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SystemSectionCreateOrConnectWithoutLogsInput
    connect?: SystemSectionWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SystemSectionUpdateOneRequiredWithoutLogsInput = {
    create?: XOR<SystemSectionCreateWithoutLogsInput, SystemSectionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SystemSectionCreateOrConnectWithoutLogsInput
    upsert?: SystemSectionUpsertWithoutLogsInput
    connect?: SystemSectionWhereUniqueInput
    update?: XOR<SystemSectionUpdateWithoutLogsInput, SystemSectionUncheckedUpdateWithoutLogsInput>
  }

  export type LogCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<LogCreateWithoutSectionInput>, Enumerable<LogUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSectionInput>
    createMany?: LogCreateManySectionInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type LogUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<LogCreateWithoutSectionInput>, Enumerable<LogUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSectionInput>
    createMany?: LogCreateManySectionInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type LogUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<LogCreateWithoutSectionInput>, Enumerable<LogUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: LogCreateManySectionInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type LogUncheckedUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<LogCreateWithoutSectionInput>, Enumerable<LogUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: LogCreateManySectionInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type EmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type EmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EmployeeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type PhoneCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutEmployeeInput>, Enumerable<PhoneUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutEmployeeInput>
    createMany?: PhoneCreateManyEmployeeInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutEmployeeInput>, Enumerable<DocumentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutEmployeeInput>
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type ContractCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<ContractCreateWithoutEmployeeInput>, Enumerable<ContractUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutEmployeeInput>
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type LoanCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutEmployeeInput>, Enumerable<LoanUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutEmployeeInput>
    createMany?: LoanCreateManyEmployeeInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type LoanPaymentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutEmployeeInput>, Enumerable<LoanPaymentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutEmployeeInput>
    createMany?: LoanPaymentCreateManyEmployeeInputEnvelope
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
  }

  export type PhoneUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutEmployeeInput>, Enumerable<PhoneUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutEmployeeInput>
    createMany?: PhoneCreateManyEmployeeInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutEmployeeInput>, Enumerable<DocumentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutEmployeeInput>
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type ContractUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<ContractCreateWithoutEmployeeInput>, Enumerable<ContractUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutEmployeeInput>
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type LoanUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutEmployeeInput>, Enumerable<LoanUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutEmployeeInput>
    createMany?: LoanCreateManyEmployeeInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutEmployeeInput>, Enumerable<LoanPaymentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutEmployeeInput>
    createMany?: LoanPaymentCreateManyEmployeeInputEnvelope
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
  }

  export type EnumEmployeesTypesFieldUpdateOperationsInput = {
    set?: EmployeesTypes
  }

  export type PhoneUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutEmployeeInput>, Enumerable<PhoneUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: PhoneCreateManyEmployeeInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutEmployeeInput>, Enumerable<DocumentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<ContractCreateWithoutEmployeeInput>, Enumerable<ContractUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type LoanUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutEmployeeInput>, Enumerable<LoanUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: LoanCreateManyEmployeeInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type LoanPaymentUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutEmployeeInput>, Enumerable<LoanPaymentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<LoanPaymentUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: LoanPaymentCreateManyEmployeeInputEnvelope
    set?: Enumerable<LoanPaymentWhereUniqueInput>
    disconnect?: Enumerable<LoanPaymentWhereUniqueInput>
    delete?: Enumerable<LoanPaymentWhereUniqueInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
    update?: Enumerable<LoanPaymentUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<LoanPaymentUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<LoanPaymentScalarWhereInput>
  }

  export type PhoneUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutEmployeeInput>, Enumerable<PhoneUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: PhoneCreateManyEmployeeInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutEmployeeInput>, Enumerable<DocumentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<ContractCreateWithoutEmployeeInput>, Enumerable<ContractUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type LoanUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutEmployeeInput>, Enumerable<LoanUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: LoanCreateManyEmployeeInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type LoanPaymentUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutEmployeeInput>, Enumerable<LoanPaymentUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<LoanPaymentUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: LoanPaymentCreateManyEmployeeInputEnvelope
    set?: Enumerable<LoanPaymentWhereUniqueInput>
    disconnect?: Enumerable<LoanPaymentWhereUniqueInput>
    delete?: Enumerable<LoanPaymentWhereUniqueInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
    update?: Enumerable<LoanPaymentUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<LoanPaymentUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<LoanPaymentScalarWhereInput>
  }

  export type BorrowerCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<BorrowerCreateWithoutDocumentsInput, BorrowerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutDocumentsInput
    connect?: BorrowerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AvalCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AvalCreateWithoutDocumentsInput, AvalUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AvalCreateOrConnectWithoutDocumentsInput
    connect?: AvalWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDocumentsInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: DocumentType
  }

  export type BorrowerUpdateOneWithoutDocumentsInput = {
    create?: XOR<BorrowerCreateWithoutDocumentsInput, BorrowerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutDocumentsInput
    upsert?: BorrowerUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BorrowerWhereUniqueInput
    update?: XOR<BorrowerUpdateWithoutDocumentsInput, BorrowerUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type AvalUpdateOneWithoutDocumentsInput = {
    create?: XOR<AvalCreateWithoutDocumentsInput, AvalUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AvalCreateOrConnectWithoutDocumentsInput
    upsert?: AvalUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AvalWhereUniqueInput
    update?: XOR<AvalUpdateWithoutDocumentsInput, AvalUncheckedUpdateWithoutDocumentsInput>
  }

  export type ContractUpdateOneWithoutDocumentsInput = {
    create?: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDocumentsInput
    upsert?: ContractUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<ContractUpdateWithoutDocumentsInput, ContractUncheckedUpdateWithoutDocumentsInput>
  }

  export type PhoneCreateNestedManyWithoutAvalInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutAvalInput>, Enumerable<PhoneUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutAvalInput>
    createMany?: PhoneCreateManyAvalInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutAvalInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutAvalInput>, Enumerable<DocumentUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutAvalInput>
    createMany?: DocumentCreateManyAvalInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type PhoneUncheckedCreateNestedManyWithoutAvalInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutAvalInput>, Enumerable<PhoneUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutAvalInput>
    createMany?: PhoneCreateManyAvalInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutAvalInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutAvalInput>, Enumerable<DocumentUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutAvalInput>
    createMany?: DocumentCreateManyAvalInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type PhoneUpdateManyWithoutAvalInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutAvalInput>, Enumerable<PhoneUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutAvalInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutAvalInput>
    createMany?: PhoneCreateManyAvalInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutAvalInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutAvalInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutAvalInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutAvalInput>, Enumerable<DocumentUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutAvalInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutAvalInput>
    createMany?: DocumentCreateManyAvalInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutAvalInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutAvalInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type PhoneUncheckedUpdateManyWithoutAvalInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutAvalInput>, Enumerable<PhoneUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutAvalInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutAvalInput>
    createMany?: PhoneCreateManyAvalInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutAvalInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutAvalInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutAvalInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutAvalInput>, Enumerable<DocumentUncheckedCreateWithoutAvalInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutAvalInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutAvalInput>
    createMany?: DocumentCreateManyAvalInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutAvalInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutAvalInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type PhoneCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutBorrowerInput>, Enumerable<PhoneUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutBorrowerInput>
    createMany?: PhoneCreateManyBorrowerInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutBorrowerInput>, Enumerable<DocumentUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutBorrowerInput>
    createMany?: DocumentCreateManyBorrowerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type ContractCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<ContractCreateWithoutBorrowerInput>, Enumerable<ContractUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutBorrowerInput>
    createMany?: ContractCreateManyBorrowerInputEnvelope
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type LocalCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<LocalCreateWithoutBorrowerInput>, Enumerable<LocalUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<LocalCreateOrConnectWithoutBorrowerInput>
    createMany?: LocalCreateManyBorrowerInputEnvelope
    connect?: Enumerable<LocalWhereUniqueInput>
  }

  export type PhoneUncheckedCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutBorrowerInput>, Enumerable<PhoneUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutBorrowerInput>
    createMany?: PhoneCreateManyBorrowerInputEnvelope
    connect?: Enumerable<PhoneWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutBorrowerInput>, Enumerable<DocumentUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutBorrowerInput>
    createMany?: DocumentCreateManyBorrowerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type ContractUncheckedCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<ContractCreateWithoutBorrowerInput>, Enumerable<ContractUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutBorrowerInput>
    createMany?: ContractCreateManyBorrowerInputEnvelope
    connect?: Enumerable<ContractWhereUniqueInput>
  }

  export type LocalUncheckedCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<LocalCreateWithoutBorrowerInput>, Enumerable<LocalUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<LocalCreateOrConnectWithoutBorrowerInput>
    createMany?: LocalCreateManyBorrowerInputEnvelope
    connect?: Enumerable<LocalWhereUniqueInput>
  }

  export type PhoneUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutBorrowerInput>, Enumerable<PhoneUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: PhoneCreateManyBorrowerInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutBorrowerInput>, Enumerable<DocumentUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: DocumentCreateManyBorrowerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type ContractUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<ContractCreateWithoutBorrowerInput>, Enumerable<ContractUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: ContractCreateManyBorrowerInputEnvelope
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type LocalUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<LocalCreateWithoutBorrowerInput>, Enumerable<LocalUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<LocalCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<LocalUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: LocalCreateManyBorrowerInputEnvelope
    set?: Enumerable<LocalWhereUniqueInput>
    disconnect?: Enumerable<LocalWhereUniqueInput>
    delete?: Enumerable<LocalWhereUniqueInput>
    connect?: Enumerable<LocalWhereUniqueInput>
    update?: Enumerable<LocalUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<LocalUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<LocalScalarWhereInput>
  }

  export type PhoneUncheckedUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<PhoneCreateWithoutBorrowerInput>, Enumerable<PhoneUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<PhoneCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<PhoneUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: PhoneCreateManyBorrowerInputEnvelope
    set?: Enumerable<PhoneWhereUniqueInput>
    disconnect?: Enumerable<PhoneWhereUniqueInput>
    delete?: Enumerable<PhoneWhereUniqueInput>
    connect?: Enumerable<PhoneWhereUniqueInput>
    update?: Enumerable<PhoneUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<PhoneUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<PhoneScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutBorrowerInput>, Enumerable<DocumentUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: DocumentCreateManyBorrowerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type ContractUncheckedUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<ContractCreateWithoutBorrowerInput>, Enumerable<ContractUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<ContractCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<ContractUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: ContractCreateManyBorrowerInputEnvelope
    set?: Enumerable<ContractWhereUniqueInput>
    disconnect?: Enumerable<ContractWhereUniqueInput>
    delete?: Enumerable<ContractWhereUniqueInput>
    connect?: Enumerable<ContractWhereUniqueInput>
    update?: Enumerable<ContractUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<ContractUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<ContractScalarWhereInput>
  }

  export type LocalUncheckedUpdateManyWithoutBorrowerInput = {
    create?: XOR<Enumerable<LocalCreateWithoutBorrowerInput>, Enumerable<LocalUncheckedCreateWithoutBorrowerInput>>
    connectOrCreate?: Enumerable<LocalCreateOrConnectWithoutBorrowerInput>
    upsert?: Enumerable<LocalUpsertWithWhereUniqueWithoutBorrowerInput>
    createMany?: LocalCreateManyBorrowerInputEnvelope
    set?: Enumerable<LocalWhereUniqueInput>
    disconnect?: Enumerable<LocalWhereUniqueInput>
    delete?: Enumerable<LocalWhereUniqueInput>
    connect?: Enumerable<LocalWhereUniqueInput>
    update?: Enumerable<LocalUpdateWithWhereUniqueWithoutBorrowerInput>
    updateMany?: Enumerable<LocalUpdateManyWithWhereWithoutBorrowerInput>
    deleteMany?: Enumerable<LocalScalarWhereInput>
  }

  export type BorrowerCreateNestedOneWithoutLocalInput = {
    create?: XOR<BorrowerCreateWithoutLocalInput, BorrowerUncheckedCreateWithoutLocalInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutLocalInput
    connect?: BorrowerWhereUniqueInput
  }

  export type BorrowerUpdateOneRequiredWithoutLocalInput = {
    create?: XOR<BorrowerCreateWithoutLocalInput, BorrowerUncheckedCreateWithoutLocalInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutLocalInput
    upsert?: BorrowerUpsertWithoutLocalInput
    connect?: BorrowerWhereUniqueInput
    update?: XOR<BorrowerUpdateWithoutLocalInput, BorrowerUncheckedUpdateWithoutLocalInput>
  }

  export type BorrowerCreateNestedOneWithoutPhonesInput = {
    create?: XOR<BorrowerCreateWithoutPhonesInput, BorrowerUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutPhonesInput
    connect?: BorrowerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPhonesInput = {
    create?: XOR<EmployeeCreateWithoutPhonesInput, EmployeeUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPhonesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AvalCreateNestedOneWithoutPhonesInput = {
    create?: XOR<AvalCreateWithoutPhonesInput, AvalUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: AvalCreateOrConnectWithoutPhonesInput
    connect?: AvalWhereUniqueInput
  }

  export type BorrowerUpdateOneWithoutPhonesInput = {
    create?: XOR<BorrowerCreateWithoutPhonesInput, BorrowerUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutPhonesInput
    upsert?: BorrowerUpsertWithoutPhonesInput
    disconnect?: boolean
    delete?: boolean
    connect?: BorrowerWhereUniqueInput
    update?: XOR<BorrowerUpdateWithoutPhonesInput, BorrowerUncheckedUpdateWithoutPhonesInput>
  }

  export type EmployeeUpdateOneWithoutPhonesInput = {
    create?: XOR<EmployeeCreateWithoutPhonesInput, EmployeeUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPhonesInput
    upsert?: EmployeeUpsertWithoutPhonesInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutPhonesInput, EmployeeUncheckedUpdateWithoutPhonesInput>
  }

  export type AvalUpdateOneWithoutPhonesInput = {
    create?: XOR<AvalCreateWithoutPhonesInput, AvalUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: AvalCreateOrConnectWithoutPhonesInput
    upsert?: AvalUpsertWithoutPhonesInput
    disconnect?: boolean
    delete?: boolean
    connect?: AvalWhereUniqueInput
    update?: XOR<AvalUpdateWithoutPhonesInput, AvalUncheckedUpdateWithoutPhonesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type LoanCreateNestedManyWithoutLoanTypeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutLoanTypeInput>, Enumerable<LoanUncheckedCreateWithoutLoanTypeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutLoanTypeInput>
    createMany?: LoanCreateManyLoanTypeInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type LoanUncheckedCreateNestedManyWithoutLoanTypeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutLoanTypeInput>, Enumerable<LoanUncheckedCreateWithoutLoanTypeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutLoanTypeInput>
    createMany?: LoanCreateManyLoanTypeInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LoanUpdateManyWithoutLoanTypeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutLoanTypeInput>, Enumerable<LoanUncheckedCreateWithoutLoanTypeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutLoanTypeInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutLoanTypeInput>
    createMany?: LoanCreateManyLoanTypeInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutLoanTypeInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutLoanTypeInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type LoanUncheckedUpdateManyWithoutLoanTypeInput = {
    create?: XOR<Enumerable<LoanCreateWithoutLoanTypeInput>, Enumerable<LoanUncheckedCreateWithoutLoanTypeInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutLoanTypeInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutLoanTypeInput>
    createMany?: LoanCreateManyLoanTypeInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutLoanTypeInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutLoanTypeInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type BorrowerCreateNestedOneWithoutContractInput = {
    create?: XOR<BorrowerCreateWithoutContractInput, BorrowerUncheckedCreateWithoutContractInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutContractInput
    connect?: BorrowerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutContractInput>, Enumerable<DocumentUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutContractInput>
    createMany?: DocumentCreateManyContractInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type LoanCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<LoanCreateWithoutContractInput>, Enumerable<LoanUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutContractInput>
    createMany?: LoanCreateManyContractInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutContractInput>, Enumerable<DocumentUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutContractInput>
    createMany?: DocumentCreateManyContractInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type LoanUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<Enumerable<LoanCreateWithoutContractInput>, Enumerable<LoanUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutContractInput>
    createMany?: LoanCreateManyContractInputEnvelope
    connect?: Enumerable<LoanWhereUniqueInput>
  }

  export type BorrowerUpdateOneRequiredWithoutContractInput = {
    create?: XOR<BorrowerCreateWithoutContractInput, BorrowerUncheckedCreateWithoutContractInput>
    connectOrCreate?: BorrowerCreateOrConnectWithoutContractInput
    upsert?: BorrowerUpsertWithoutContractInput
    connect?: BorrowerWhereUniqueInput
    update?: XOR<BorrowerUpdateWithoutContractInput, BorrowerUncheckedUpdateWithoutContractInput>
  }

  export type EmployeeUpdateOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    upsert?: EmployeeUpsertWithoutContractsInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type DocumentUpdateManyWithoutContractInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutContractInput>, Enumerable<DocumentUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutContractInput>
    createMany?: DocumentCreateManyContractInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type LoanUpdateManyWithoutContractInput = {
    create?: XOR<Enumerable<LoanCreateWithoutContractInput>, Enumerable<LoanUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutContractInput>
    createMany?: LoanCreateManyContractInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutContractInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutContractInput>, Enumerable<DocumentUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutContractInput>
    createMany?: DocumentCreateManyContractInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type LoanUncheckedUpdateManyWithoutContractInput = {
    create?: XOR<Enumerable<LoanCreateWithoutContractInput>, Enumerable<LoanUncheckedCreateWithoutContractInput>>
    connectOrCreate?: Enumerable<LoanCreateOrConnectWithoutContractInput>
    upsert?: Enumerable<LoanUpsertWithWhereUniqueWithoutContractInput>
    createMany?: LoanCreateManyContractInputEnvelope
    set?: Enumerable<LoanWhereUniqueInput>
    disconnect?: Enumerable<LoanWhereUniqueInput>
    delete?: Enumerable<LoanWhereUniqueInput>
    connect?: Enumerable<LoanWhereUniqueInput>
    update?: Enumerable<LoanUpdateWithWhereUniqueWithoutContractInput>
    updateMany?: Enumerable<LoanUpdateManyWithWhereWithoutContractInput>
    deleteMany?: Enumerable<LoanScalarWhereInput>
  }

  export type LoanPaymentCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutLoanInput>, Enumerable<LoanPaymentUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutLoanInput>
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
  }

  export type LoantypeCreateNestedOneWithoutLoanInput = {
    create?: XOR<LoantypeCreateWithoutLoanInput, LoantypeUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoantypeCreateOrConnectWithoutLoanInput
    connect?: LoantypeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLoanInput = {
    create?: XOR<EmployeeCreateWithoutLoanInput, EmployeeUncheckedCreateWithoutLoanInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoanInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutLoansInput = {
    create?: XOR<ContractCreateWithoutLoansInput, ContractUncheckedCreateWithoutLoansInput>
    connectOrCreate?: ContractCreateOrConnectWithoutLoansInput
    connect?: ContractWhereUniqueInput
  }

  export type PaymentScheduleCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanInput>
    createMany?: PaymentScheduleCreateManyLoanInputEnvelope
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutLoanInput>, Enumerable<LoanPaymentUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutLoanInput>
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
  }

  export type PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanInput>
    createMany?: PaymentScheduleCreateManyLoanInputEnvelope
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
  }

  export type EnumLoanStateFieldUpdateOperationsInput = {
    set?: LoanState
  }

  export type LoanPaymentUpdateManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutLoanInput>, Enumerable<LoanPaymentUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<LoanPaymentUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: Enumerable<LoanPaymentWhereUniqueInput>
    disconnect?: Enumerable<LoanPaymentWhereUniqueInput>
    delete?: Enumerable<LoanPaymentWhereUniqueInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
    update?: Enumerable<LoanPaymentUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<LoanPaymentUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<LoanPaymentScalarWhereInput>
  }

  export type LoantypeUpdateOneRequiredWithoutLoanInput = {
    create?: XOR<LoantypeCreateWithoutLoanInput, LoantypeUncheckedCreateWithoutLoanInput>
    connectOrCreate?: LoantypeCreateOrConnectWithoutLoanInput
    upsert?: LoantypeUpsertWithoutLoanInput
    connect?: LoantypeWhereUniqueInput
    update?: XOR<LoantypeUpdateWithoutLoanInput, LoantypeUncheckedUpdateWithoutLoanInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLoanInput = {
    create?: XOR<EmployeeCreateWithoutLoanInput, EmployeeUncheckedCreateWithoutLoanInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoanInput
    upsert?: EmployeeUpsertWithoutLoanInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutLoanInput, EmployeeUncheckedUpdateWithoutLoanInput>
  }

  export type ContractUpdateOneRequiredWithoutLoansInput = {
    create?: XOR<ContractCreateWithoutLoansInput, ContractUncheckedCreateWithoutLoansInput>
    connectOrCreate?: ContractCreateOrConnectWithoutLoansInput
    upsert?: ContractUpsertWithoutLoansInput
    connect?: ContractWhereUniqueInput
    update?: XOR<ContractUpdateWithoutLoansInput, ContractUncheckedUpdateWithoutLoansInput>
  }

  export type PaymentScheduleUpdateManyWithoutLoanInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<PaymentScheduleUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: PaymentScheduleCreateManyLoanInputEnvelope
    set?: Enumerable<PaymentScheduleWhereUniqueInput>
    disconnect?: Enumerable<PaymentScheduleWhereUniqueInput>
    delete?: Enumerable<PaymentScheduleWhereUniqueInput>
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
    update?: Enumerable<PaymentScheduleUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<PaymentScheduleUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<PaymentScheduleScalarWhereInput>
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutLoanInput>, Enumerable<LoanPaymentUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<LoanPaymentUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: Enumerable<LoanPaymentWhereUniqueInput>
    disconnect?: Enumerable<LoanPaymentWhereUniqueInput>
    delete?: Enumerable<LoanPaymentWhereUniqueInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
    update?: Enumerable<LoanPaymentUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<LoanPaymentUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<LoanPaymentScalarWhereInput>
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutLoanInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanInput>
    upsert?: Enumerable<PaymentScheduleUpsertWithWhereUniqueWithoutLoanInput>
    createMany?: PaymentScheduleCreateManyLoanInputEnvelope
    set?: Enumerable<PaymentScheduleWhereUniqueInput>
    disconnect?: Enumerable<PaymentScheduleWhereUniqueInput>
    delete?: Enumerable<PaymentScheduleWhereUniqueInput>
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
    update?: Enumerable<PaymentScheduleUpdateWithWhereUniqueWithoutLoanInput>
    updateMany?: Enumerable<PaymentScheduleUpdateManyWithWhereWithoutLoanInput>
    deleteMany?: Enumerable<PaymentScheduleScalarWhereInput>
  }

  export type PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanPaymentsInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanPaymentsInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanPaymentsInput>
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
  }

  export type LoanCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentsInput
    connect?: LoanWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLoanPaymentInput = {
    create?: XOR<EmployeeCreateWithoutLoanPaymentInput, EmployeeUncheckedCreateWithoutLoanPaymentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoanPaymentInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PaymentScheduleUpdateManyWithoutLoanPaymentsInput = {
    create?: XOR<Enumerable<PaymentScheduleCreateWithoutLoanPaymentsInput>, Enumerable<PaymentScheduleUncheckedCreateWithoutLoanPaymentsInput>>
    connectOrCreate?: Enumerable<PaymentScheduleCreateOrConnectWithoutLoanPaymentsInput>
    upsert?: Enumerable<PaymentScheduleUpsertWithWhereUniqueWithoutLoanPaymentsInput>
    set?: Enumerable<PaymentScheduleWhereUniqueInput>
    disconnect?: Enumerable<PaymentScheduleWhereUniqueInput>
    delete?: Enumerable<PaymentScheduleWhereUniqueInput>
    connect?: Enumerable<PaymentScheduleWhereUniqueInput>
    update?: Enumerable<PaymentScheduleUpdateWithWhereUniqueWithoutLoanPaymentsInput>
    updateMany?: Enumerable<PaymentScheduleUpdateManyWithWhereWithoutLoanPaymentsInput>
    deleteMany?: Enumerable<PaymentScheduleScalarWhereInput>
  }

  export type LoanUpdateOneRequiredWithoutPaymentsInput = {
    create?: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentsInput
    upsert?: LoanUpsertWithoutPaymentsInput
    connect?: LoanWhereUniqueInput
    update?: XOR<LoanUpdateWithoutPaymentsInput, LoanUncheckedUpdateWithoutPaymentsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLoanPaymentInput = {
    create?: XOR<EmployeeCreateWithoutLoanPaymentInput, EmployeeUncheckedCreateWithoutLoanPaymentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLoanPaymentInput
    upsert?: EmployeeUpsertWithoutLoanPaymentInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutLoanPaymentInput, EmployeeUncheckedUpdateWithoutLoanPaymentInput>
  }

  export type LoanCreateNestedOneWithoutPaymentScheduleInput = {
    create?: XOR<LoanCreateWithoutPaymentScheduleInput, LoanUncheckedCreateWithoutPaymentScheduleInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentScheduleInput
    connect?: LoanWhereUniqueInput
  }

  export type LoanPaymentCreateNestedManyWithoutPaymentSchedulesInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutPaymentSchedulesInput>, Enumerable<LoanPaymentUncheckedCreateWithoutPaymentSchedulesInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutPaymentSchedulesInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
  }

  export type EnumPaymentStateFieldUpdateOperationsInput = {
    set?: PaymentState
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LoanUpdateOneRequiredWithoutPaymentScheduleInput = {
    create?: XOR<LoanCreateWithoutPaymentScheduleInput, LoanUncheckedCreateWithoutPaymentScheduleInput>
    connectOrCreate?: LoanCreateOrConnectWithoutPaymentScheduleInput
    upsert?: LoanUpsertWithoutPaymentScheduleInput
    connect?: LoanWhereUniqueInput
    update?: XOR<LoanUpdateWithoutPaymentScheduleInput, LoanUncheckedUpdateWithoutPaymentScheduleInput>
  }

  export type LoanPaymentUpdateManyWithoutPaymentSchedulesInput = {
    create?: XOR<Enumerable<LoanPaymentCreateWithoutPaymentSchedulesInput>, Enumerable<LoanPaymentUncheckedCreateWithoutPaymentSchedulesInput>>
    connectOrCreate?: Enumerable<LoanPaymentCreateOrConnectWithoutPaymentSchedulesInput>
    upsert?: Enumerable<LoanPaymentUpsertWithWhereUniqueWithoutPaymentSchedulesInput>
    set?: Enumerable<LoanPaymentWhereUniqueInput>
    disconnect?: Enumerable<LoanPaymentWhereUniqueInput>
    delete?: Enumerable<LoanPaymentWhereUniqueInput>
    connect?: Enumerable<LoanPaymentWhereUniqueInput>
    update?: Enumerable<LoanPaymentUpdateWithWhereUniqueWithoutPaymentSchedulesInput>
    updateMany?: Enumerable<LoanPaymentUpdateManyWithWhereWithoutPaymentSchedulesInput>
    deleteMany?: Enumerable<LoanPaymentScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumEmployeesTypesFilter = {
    equals?: EmployeesTypes
    in?: Enumerable<EmployeesTypes>
    notIn?: Enumerable<EmployeesTypes>
    not?: NestedEnumEmployeesTypesFilter | EmployeesTypes
  }

  export type NestedEnumEmployeesTypesWithAggregatesFilter = {
    equals?: EmployeesTypes
    in?: Enumerable<EmployeesTypes>
    notIn?: Enumerable<EmployeesTypes>
    not?: NestedEnumEmployeesTypesWithAggregatesFilter | EmployeesTypes
    _count?: NestedIntFilter
    _min?: NestedEnumEmployeesTypesFilter
    _max?: NestedEnumEmployeesTypesFilter
  }

  export type NestedEnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumLoanStateFilter = {
    equals?: LoanState
    in?: Enumerable<LoanState>
    notIn?: Enumerable<LoanState>
    not?: NestedEnumLoanStateFilter | LoanState
  }

  export type NestedEnumLoanStateWithAggregatesFilter = {
    equals?: LoanState
    in?: Enumerable<LoanState>
    notIn?: Enumerable<LoanState>
    not?: NestedEnumLoanStateWithAggregatesFilter | LoanState
    _count?: NestedIntFilter
    _min?: NestedEnumLoanStateFilter
    _max?: NestedEnumLoanStateFilter
  }

  export type NestedEnumPaymentStateFilter = {
    equals?: PaymentState
    in?: Enumerable<PaymentState>
    notIn?: Enumerable<PaymentState>
    not?: NestedEnumPaymentStateFilter | PaymentState
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumPaymentStateWithAggregatesFilter = {
    equals?: PaymentState
    in?: Enumerable<PaymentState>
    notIn?: Enumerable<PaymentState>
    not?: NestedEnumPaymentStateWithAggregatesFilter | PaymentState
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStateFilter
    _max?: NestedEnumPaymentStateFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SystemSectionCreateWithoutLogsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSectionUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSectionCreateOrConnectWithoutLogsInput = {
    where: SystemSectionWhereUniqueInput
    create: XOR<SystemSectionCreateWithoutLogsInput, SystemSectionUncheckedCreateWithoutLogsInput>
  }

  export type SystemSectionUpsertWithoutLogsInput = {
    update: XOR<SystemSectionUpdateWithoutLogsInput, SystemSectionUncheckedUpdateWithoutLogsInput>
    create: XOR<SystemSectionCreateWithoutLogsInput, SystemSectionUncheckedCreateWithoutLogsInput>
  }

  export type SystemSectionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSectionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateWithoutSectionInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUncheckedCreateWithoutSectionInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogCreateOrConnectWithoutSectionInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutSectionInput, LogUncheckedCreateWithoutSectionInput>
  }

  export type LogCreateManySectionInputEnvelope = {
    data: Enumerable<LogCreateManySectionInput>
    skipDuplicates?: boolean
  }

  export type LogUpsertWithWhereUniqueWithoutSectionInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutSectionInput, LogUncheckedUpdateWithoutSectionInput>
    create: XOR<LogCreateWithoutSectionInput, LogUncheckedCreateWithoutSectionInput>
  }

  export type LogUpdateWithWhereUniqueWithoutSectionInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutSectionInput, LogUncheckedUpdateWithoutSectionInput>
  }

  export type LogUpdateManyWithWhereWithoutSectionInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogsInput>
  }

  export type LogScalarWhereInput = {
    AND?: Enumerable<LogScalarWhereInput>
    OR?: Enumerable<LogScalarWhereInput>
    NOT?: Enumerable<LogScalarWhereInput>
    id?: StringFilter | string
    requestBody?: StringFilter | string
    requestType?: StringFilter | string
    deviceType?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    systemSectionId?: StringFilter | string
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateManyUserInputEnvelope = {
    data: Enumerable<EmployeeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: Enumerable<EmployeeScalarWhereInput>
    OR?: Enumerable<EmployeeScalarWhereInput>
    NOT?: Enumerable<EmployeeScalarWhereInput>
    id?: StringFilter | string
    type?: EnumEmployeesTypesFilter | EmployeesTypes
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
  }

  export type PhoneCreateWithoutEmployeeInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Borrower?: BorrowerCreateNestedOneWithoutPhonesInput
    aval?: AvalCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateWithoutEmployeeInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
  }

  export type PhoneCreateOrConnectWithoutEmployeeInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutEmployeeInput, PhoneUncheckedCreateWithoutEmployeeInput>
  }

  export type PhoneCreateManyEmployeeInputEnvelope = {
    data: Enumerable<PhoneCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutEmployeeInput = {
    id?: string
    type: DocumentType
    Borrower?: BorrowerCreateNestedOneWithoutDocumentsInput
    aval?: AvalCreateNestedOneWithoutDocumentsInput
    Contract?: ContractCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    contractId?: string | null
  }

  export type DocumentCreateOrConnectWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentCreateManyEmployeeInputEnvelope = {
    data: Enumerable<DocumentCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin?: Date | string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    password: string
    lastLogin?: Date | string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateWithoutEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    borrower: BorrowerCreateNestedOneWithoutContractInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    loans?: LoanCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    loans?: LoanUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateManyEmployeeInputEnvelope = {
    data: Enumerable<ContractCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type LoanCreateWithoutEmployeeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
    loanType: LoantypeCreateNestedOneWithoutLoanInput
    contract: ContractCreateNestedOneWithoutLoansInput
    paymentSchedule?: PaymentScheduleCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutEmployeeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanCreateManyEmployeeInputEnvelope = {
    data: Enumerable<LoanCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type LoanPaymentCreateWithoutEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput
    loan: LoanCreateNestedOneWithoutPaymentsInput
  }

  export type LoanPaymentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
  }

  export type LoanPaymentCreateOrConnectWithoutEmployeeInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutEmployeeInput, LoanPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanPaymentCreateManyEmployeeInputEnvelope = {
    data: Enumerable<LoanPaymentCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type PhoneUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PhoneWhereUniqueInput
    update: XOR<PhoneUpdateWithoutEmployeeInput, PhoneUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PhoneCreateWithoutEmployeeInput, PhoneUncheckedCreateWithoutEmployeeInput>
  }

  export type PhoneUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PhoneWhereUniqueInput
    data: XOR<PhoneUpdateWithoutEmployeeInput, PhoneUncheckedUpdateWithoutEmployeeInput>
  }

  export type PhoneUpdateManyWithWhereWithoutEmployeeInput = {
    where: PhoneScalarWhereInput
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyWithoutPhonesInput>
  }

  export type PhoneScalarWhereInput = {
    AND?: Enumerable<PhoneScalarWhereInput>
    OR?: Enumerable<PhoneScalarWhereInput>
    NOT?: Enumerable<PhoneScalarWhereInput>
    id?: StringFilter | string
    number?: StringFilter | string
    borrowerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    avalId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    type?: EnumDocumentTypeFilter | DocumentType
    borrowerId?: StringNullableFilter | string | null
    avalId?: StringNullableFilter | string | null
    contractId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithWhereWithoutEmployeeInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutContractsInput>
  }

  export type ContractScalarWhereInput = {
    AND?: Enumerable<ContractScalarWhereInput>
    OR?: Enumerable<ContractScalarWhereInput>
    NOT?: Enumerable<ContractScalarWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | number | string
    borrowerId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    dueDate?: DateTimeFilter | Date | string
    signDate?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    employeeId?: StringFilter | string
  }

  export type LoanUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutEmployeeInput, LoanUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LoanCreateWithoutEmployeeInput, LoanUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutEmployeeInput, LoanUncheckedUpdateWithoutEmployeeInput>
  }

  export type LoanUpdateManyWithWhereWithoutEmployeeInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutLoanInput>
  }

  export type LoanScalarWhereInput = {
    AND?: Enumerable<LoanScalarWhereInput>
    OR?: Enumerable<LoanScalarWhereInput>
    NOT?: Enumerable<LoanScalarWhereInput>
    id?: StringFilter | string
    status?: EnumLoanStateFilter | LoanState
    weeklyPaymentAmount?: DecimalFilter | Decimal | number | string
    amountToPay?: DecimalFilter | Decimal | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    contractId?: StringFilter | string
    loantypeId?: StringFilter | string
    employeeId?: StringFilter | string
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutEmployeeInput, LoanPaymentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LoanPaymentCreateWithoutEmployeeInput, LoanPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutEmployeeInput, LoanPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutEmployeeInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutLoanPaymentInput>
  }

  export type LoanPaymentScalarWhereInput = {
    AND?: Enumerable<LoanPaymentScalarWhereInput>
    OR?: Enumerable<LoanPaymentScalarWhereInput>
    NOT?: Enumerable<LoanPaymentScalarWhereInput>
    id?: StringFilter | string
    amount?: DecimalFilter | Decimal | number | string
    date?: DateTimeFilter | Date | string
    comments?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    loanId?: StringFilter | string
    employeeId?: StringFilter | string
  }

  export type BorrowerCreateWithoutDocumentsInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutBorrowerInput
    Contract?: ContractCreateNestedManyWithoutBorrowerInput
    Local?: LocalCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutBorrowerInput
    Contract?: ContractUncheckedCreateNestedManyWithoutBorrowerInput
    Local?: LocalUncheckedCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerCreateOrConnectWithoutDocumentsInput = {
    where: BorrowerWhereUniqueInput
    create: XOR<BorrowerCreateWithoutDocumentsInput, BorrowerUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type AvalCreateWithoutDocumentsInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutAvalInput
  }

  export type AvalUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutAvalInput
  }

  export type AvalCreateOrConnectWithoutDocumentsInput = {
    where: AvalWhereUniqueInput
    create: XOR<AvalCreateWithoutDocumentsInput, AvalUncheckedCreateWithoutDocumentsInput>
  }

  export type ContractCreateWithoutDocumentsInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    borrower: BorrowerCreateNestedOneWithoutContractInput
    employee?: EmployeeCreateNestedOneWithoutContractsInput
    loans?: LoanCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutDocumentsInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
    loans?: LoanUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutDocumentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
  }

  export type BorrowerUpsertWithoutDocumentsInput = {
    update: XOR<BorrowerUpdateWithoutDocumentsInput, BorrowerUncheckedUpdateWithoutDocumentsInput>
    create: XOR<BorrowerCreateWithoutDocumentsInput, BorrowerUncheckedCreateWithoutDocumentsInput>
  }

  export type BorrowerUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutBorrowerInput
    Contract?: ContractUpdateManyWithoutBorrowerInput
    Local?: LocalUpdateManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutBorrowerInput
    Contract?: ContractUncheckedUpdateManyWithoutBorrowerInput
    Local?: LocalUncheckedUpdateManyWithoutBorrowerInput
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type AvalUpsertWithoutDocumentsInput = {
    update: XOR<AvalUpdateWithoutDocumentsInput, AvalUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AvalCreateWithoutDocumentsInput, AvalUncheckedCreateWithoutDocumentsInput>
  }

  export type AvalUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutAvalInput
  }

  export type AvalUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutAvalInput
  }

  export type ContractUpsertWithoutDocumentsInput = {
    update: XOR<ContractUpdateWithoutDocumentsInput, ContractUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
  }

  export type ContractUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: BorrowerUpdateOneRequiredWithoutContractInput
    employee?: EmployeeUpdateOneWithoutContractsInput
    loans?: LoanUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    loans?: LoanUncheckedUpdateManyWithoutContractInput
  }

  export type PhoneCreateWithoutAvalInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Borrower?: BorrowerCreateNestedOneWithoutPhonesInput
    Employee?: EmployeeCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateWithoutAvalInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
  }

  export type PhoneCreateOrConnectWithoutAvalInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutAvalInput, PhoneUncheckedCreateWithoutAvalInput>
  }

  export type PhoneCreateManyAvalInputEnvelope = {
    data: Enumerable<PhoneCreateManyAvalInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutAvalInput = {
    id?: string
    type: DocumentType
    Borrower?: BorrowerCreateNestedOneWithoutDocumentsInput
    Employee?: EmployeeCreateNestedOneWithoutDocumentsInput
    Contract?: ContractCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutAvalInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type DocumentCreateOrConnectWithoutAvalInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAvalInput, DocumentUncheckedCreateWithoutAvalInput>
  }

  export type DocumentCreateManyAvalInputEnvelope = {
    data: Enumerable<DocumentCreateManyAvalInput>
    skipDuplicates?: boolean
  }

  export type PhoneUpsertWithWhereUniqueWithoutAvalInput = {
    where: PhoneWhereUniqueInput
    update: XOR<PhoneUpdateWithoutAvalInput, PhoneUncheckedUpdateWithoutAvalInput>
    create: XOR<PhoneCreateWithoutAvalInput, PhoneUncheckedCreateWithoutAvalInput>
  }

  export type PhoneUpdateWithWhereUniqueWithoutAvalInput = {
    where: PhoneWhereUniqueInput
    data: XOR<PhoneUpdateWithoutAvalInput, PhoneUncheckedUpdateWithoutAvalInput>
  }

  export type PhoneUpdateManyWithWhereWithoutAvalInput = {
    where: PhoneScalarWhereInput
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyWithoutPhonesInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutAvalInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutAvalInput, DocumentUncheckedUpdateWithoutAvalInput>
    create: XOR<DocumentCreateWithoutAvalInput, DocumentUncheckedCreateWithoutAvalInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutAvalInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutAvalInput, DocumentUncheckedUpdateWithoutAvalInput>
  }

  export type DocumentUpdateManyWithWhereWithoutAvalInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type PhoneCreateWithoutBorrowerInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeCreateNestedOneWithoutPhonesInput
    aval?: AvalCreateNestedOneWithoutPhonesInput
  }

  export type PhoneUncheckedCreateWithoutBorrowerInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
    employeeId?: string | null
  }

  export type PhoneCreateOrConnectWithoutBorrowerInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutBorrowerInput, PhoneUncheckedCreateWithoutBorrowerInput>
  }

  export type PhoneCreateManyBorrowerInputEnvelope = {
    data: Enumerable<PhoneCreateManyBorrowerInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutBorrowerInput = {
    id?: string
    type: DocumentType
    Employee?: EmployeeCreateNestedOneWithoutDocumentsInput
    aval?: AvalCreateNestedOneWithoutDocumentsInput
    Contract?: ContractCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutBorrowerInput = {
    id?: string
    type: DocumentType
    avalId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type DocumentCreateOrConnectWithoutBorrowerInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutBorrowerInput, DocumentUncheckedCreateWithoutBorrowerInput>
  }

  export type DocumentCreateManyBorrowerInputEnvelope = {
    data: Enumerable<DocumentCreateManyBorrowerInput>
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutBorrowerInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    loans?: LoanCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutBorrowerInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    loans?: LoanUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutBorrowerInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutBorrowerInput, ContractUncheckedCreateWithoutBorrowerInput>
  }

  export type ContractCreateManyBorrowerInputEnvelope = {
    data: Enumerable<ContractCreateManyBorrowerInput>
    skipDuplicates?: boolean
  }

  export type LocalCreateWithoutBorrowerInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalUncheckedCreateWithoutBorrowerInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalCreateOrConnectWithoutBorrowerInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutBorrowerInput, LocalUncheckedCreateWithoutBorrowerInput>
  }

  export type LocalCreateManyBorrowerInputEnvelope = {
    data: Enumerable<LocalCreateManyBorrowerInput>
    skipDuplicates?: boolean
  }

  export type PhoneUpsertWithWhereUniqueWithoutBorrowerInput = {
    where: PhoneWhereUniqueInput
    update: XOR<PhoneUpdateWithoutBorrowerInput, PhoneUncheckedUpdateWithoutBorrowerInput>
    create: XOR<PhoneCreateWithoutBorrowerInput, PhoneUncheckedCreateWithoutBorrowerInput>
  }

  export type PhoneUpdateWithWhereUniqueWithoutBorrowerInput = {
    where: PhoneWhereUniqueInput
    data: XOR<PhoneUpdateWithoutBorrowerInput, PhoneUncheckedUpdateWithoutBorrowerInput>
  }

  export type PhoneUpdateManyWithWhereWithoutBorrowerInput = {
    where: PhoneScalarWhereInput
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyWithoutPhonesInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutBorrowerInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutBorrowerInput, DocumentUncheckedUpdateWithoutBorrowerInput>
    create: XOR<DocumentCreateWithoutBorrowerInput, DocumentUncheckedCreateWithoutBorrowerInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutBorrowerInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutBorrowerInput, DocumentUncheckedUpdateWithoutBorrowerInput>
  }

  export type DocumentUpdateManyWithWhereWithoutBorrowerInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type ContractUpsertWithWhereUniqueWithoutBorrowerInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutBorrowerInput, ContractUncheckedUpdateWithoutBorrowerInput>
    create: XOR<ContractCreateWithoutBorrowerInput, ContractUncheckedCreateWithoutBorrowerInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutBorrowerInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutBorrowerInput, ContractUncheckedUpdateWithoutBorrowerInput>
  }

  export type ContractUpdateManyWithWhereWithoutBorrowerInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutContractInput>
  }

  export type LocalUpsertWithWhereUniqueWithoutBorrowerInput = {
    where: LocalWhereUniqueInput
    update: XOR<LocalUpdateWithoutBorrowerInput, LocalUncheckedUpdateWithoutBorrowerInput>
    create: XOR<LocalCreateWithoutBorrowerInput, LocalUncheckedCreateWithoutBorrowerInput>
  }

  export type LocalUpdateWithWhereUniqueWithoutBorrowerInput = {
    where: LocalWhereUniqueInput
    data: XOR<LocalUpdateWithoutBorrowerInput, LocalUncheckedUpdateWithoutBorrowerInput>
  }

  export type LocalUpdateManyWithWhereWithoutBorrowerInput = {
    where: LocalScalarWhereInput
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyWithoutLocalInput>
  }

  export type LocalScalarWhereInput = {
    AND?: Enumerable<LocalScalarWhereInput>
    OR?: Enumerable<LocalScalarWhereInput>
    NOT?: Enumerable<LocalScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    borrowerId?: StringFilter | string
  }

  export type BorrowerCreateWithoutLocalInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutBorrowerInput
    documents?: DocumentCreateNestedManyWithoutBorrowerInput
    Contract?: ContractCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedCreateWithoutLocalInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutBorrowerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutBorrowerInput
    Contract?: ContractUncheckedCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerCreateOrConnectWithoutLocalInput = {
    where: BorrowerWhereUniqueInput
    create: XOR<BorrowerCreateWithoutLocalInput, BorrowerUncheckedCreateWithoutLocalInput>
  }

  export type BorrowerUpsertWithoutLocalInput = {
    update: XOR<BorrowerUpdateWithoutLocalInput, BorrowerUncheckedUpdateWithoutLocalInput>
    create: XOR<BorrowerCreateWithoutLocalInput, BorrowerUncheckedCreateWithoutLocalInput>
  }

  export type BorrowerUpdateWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutBorrowerInput
    documents?: DocumentUpdateManyWithoutBorrowerInput
    Contract?: ContractUpdateManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedUpdateWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutBorrowerInput
    documents?: DocumentUncheckedUpdateManyWithoutBorrowerInput
    Contract?: ContractUncheckedUpdateManyWithoutBorrowerInput
  }

  export type BorrowerCreateWithoutPhonesInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutBorrowerInput
    Contract?: ContractCreateNestedManyWithoutBorrowerInput
    Local?: LocalCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedCreateWithoutPhonesInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutBorrowerInput
    Contract?: ContractUncheckedCreateNestedManyWithoutBorrowerInput
    Local?: LocalUncheckedCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerCreateOrConnectWithoutPhonesInput = {
    where: BorrowerWhereUniqueInput
    create: XOR<BorrowerCreateWithoutPhonesInput, BorrowerUncheckedCreateWithoutPhonesInput>
  }

  export type EmployeeCreateWithoutPhonesInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPhonesInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPhonesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPhonesInput, EmployeeUncheckedCreateWithoutPhonesInput>
  }

  export type AvalCreateWithoutPhonesInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutAvalInput
  }

  export type AvalUncheckedCreateWithoutPhonesInput = {
    id?: string
    email: string
    fullName: string
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutAvalInput
  }

  export type AvalCreateOrConnectWithoutPhonesInput = {
    where: AvalWhereUniqueInput
    create: XOR<AvalCreateWithoutPhonesInput, AvalUncheckedCreateWithoutPhonesInput>
  }

  export type BorrowerUpsertWithoutPhonesInput = {
    update: XOR<BorrowerUpdateWithoutPhonesInput, BorrowerUncheckedUpdateWithoutPhonesInput>
    create: XOR<BorrowerCreateWithoutPhonesInput, BorrowerUncheckedCreateWithoutPhonesInput>
  }

  export type BorrowerUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutBorrowerInput
    Contract?: ContractUpdateManyWithoutBorrowerInput
    Local?: LocalUpdateManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutBorrowerInput
    Contract?: ContractUncheckedUpdateManyWithoutBorrowerInput
    Local?: LocalUncheckedUpdateManyWithoutBorrowerInput
  }

  export type EmployeeUpsertWithoutPhonesInput = {
    update: XOR<EmployeeUpdateWithoutPhonesInput, EmployeeUncheckedUpdateWithoutPhonesInput>
    create: XOR<EmployeeCreateWithoutPhonesInput, EmployeeUncheckedCreateWithoutPhonesInput>
  }

  export type EmployeeUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type AvalUpsertWithoutPhonesInput = {
    update: XOR<AvalUpdateWithoutPhonesInput, AvalUncheckedUpdateWithoutPhonesInput>
    create: XOR<AvalCreateWithoutPhonesInput, AvalUncheckedCreateWithoutPhonesInput>
  }

  export type AvalUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutAvalInput
  }

  export type AvalUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutAvalInput
  }

  export type LoanCreateWithoutLoanTypeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
    employee: EmployeeCreateNestedOneWithoutLoanInput
    contract: ContractCreateNestedOneWithoutLoansInput
    paymentSchedule?: PaymentScheduleCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutLoanTypeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    employeeId: string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutLoanTypeInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutLoanTypeInput, LoanUncheckedCreateWithoutLoanTypeInput>
  }

  export type LoanCreateManyLoanTypeInputEnvelope = {
    data: Enumerable<LoanCreateManyLoanTypeInput>
    skipDuplicates?: boolean
  }

  export type LoanUpsertWithWhereUniqueWithoutLoanTypeInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutLoanTypeInput, LoanUncheckedUpdateWithoutLoanTypeInput>
    create: XOR<LoanCreateWithoutLoanTypeInput, LoanUncheckedCreateWithoutLoanTypeInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutLoanTypeInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutLoanTypeInput, LoanUncheckedUpdateWithoutLoanTypeInput>
  }

  export type LoanUpdateManyWithWhereWithoutLoanTypeInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutLoanInput>
  }

  export type BorrowerCreateWithoutContractInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutBorrowerInput
    documents?: DocumentCreateNestedManyWithoutBorrowerInput
    Local?: LocalCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedCreateWithoutContractInput = {
    id?: string
    name: string
    address: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneUncheckedCreateNestedManyWithoutBorrowerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutBorrowerInput
    Local?: LocalUncheckedCreateNestedManyWithoutBorrowerInput
  }

  export type BorrowerCreateOrConnectWithoutContractInput = {
    where: BorrowerWhereUniqueInput
    create: XOR<BorrowerCreateWithoutContractInput, BorrowerUncheckedCreateWithoutContractInput>
  }

  export type EmployeeCreateWithoutContractsInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutContractsInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutContractsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type DocumentCreateWithoutContractInput = {
    id?: string
    type: DocumentType
    Borrower?: BorrowerCreateNestedOneWithoutDocumentsInput
    Employee?: EmployeeCreateNestedOneWithoutDocumentsInput
    aval?: AvalCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutContractInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    employeeId?: string | null
  }

  export type DocumentCreateOrConnectWithoutContractInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput>
  }

  export type DocumentCreateManyContractInputEnvelope = {
    data: Enumerable<DocumentCreateManyContractInput>
    skipDuplicates?: boolean
  }

  export type LoanCreateWithoutContractInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
    loanType: LoantypeCreateNestedOneWithoutLoanInput
    employee: EmployeeCreateNestedOneWithoutLoanInput
    paymentSchedule?: PaymentScheduleCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutContractInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loantypeId: string
    employeeId: string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutContractInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutContractInput, LoanUncheckedCreateWithoutContractInput>
  }

  export type LoanCreateManyContractInputEnvelope = {
    data: Enumerable<LoanCreateManyContractInput>
    skipDuplicates?: boolean
  }

  export type BorrowerUpsertWithoutContractInput = {
    update: XOR<BorrowerUpdateWithoutContractInput, BorrowerUncheckedUpdateWithoutContractInput>
    create: XOR<BorrowerCreateWithoutContractInput, BorrowerUncheckedCreateWithoutContractInput>
  }

  export type BorrowerUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutBorrowerInput
    documents?: DocumentUpdateManyWithoutBorrowerInput
    Local?: LocalUpdateManyWithoutBorrowerInput
  }

  export type BorrowerUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutBorrowerInput
    documents?: DocumentUncheckedUpdateManyWithoutBorrowerInput
    Local?: LocalUncheckedUpdateManyWithoutBorrowerInput
  }

  export type EmployeeUpsertWithoutContractsInput = {
    update: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type EmployeeUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    documents?: DocumentUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutContractInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutContractInput, DocumentUncheckedUpdateWithoutContractInput>
    create: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutContractInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutContractInput, DocumentUncheckedUpdateWithoutContractInput>
  }

  export type DocumentUpdateManyWithWhereWithoutContractInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type LoanUpsertWithWhereUniqueWithoutContractInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutContractInput, LoanUncheckedUpdateWithoutContractInput>
    create: XOR<LoanCreateWithoutContractInput, LoanUncheckedCreateWithoutContractInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutContractInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutContractInput, LoanUncheckedUpdateWithoutContractInput>
  }

  export type LoanUpdateManyWithWhereWithoutContractInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutLoansInput>
  }

  export type LoanPaymentCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentSchedules?: PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput
    employee: EmployeeCreateNestedOneWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedCreateWithoutLoanInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type LoanPaymentCreateOrConnectWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentCreateManyLoanInputEnvelope = {
    data: Enumerable<LoanPaymentCreateManyLoanInput>
    skipDuplicates?: boolean
  }

  export type LoantypeCreateWithoutLoanInput = {
    id?: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoantypeUncheckedCreateWithoutLoanInput = {
    id?: string
    name: string
    weekDuration: number
    rate: number
    overdueRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoantypeCreateOrConnectWithoutLoanInput = {
    where: LoantypeWhereUniqueInput
    create: XOR<LoantypeCreateWithoutLoanInput, LoantypeUncheckedCreateWithoutLoanInput>
  }

  export type EmployeeCreateWithoutLoanInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLoanInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLoanInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLoanInput, EmployeeUncheckedCreateWithoutLoanInput>
  }

  export type ContractCreateWithoutLoansInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    borrower: BorrowerCreateNestedOneWithoutContractInput
    employee?: EmployeeCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutLoansInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutLoansInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutLoansInput, ContractUncheckedCreateWithoutLoansInput>
  }

  export type PaymentScheduleCreateWithoutLoanInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanPayments?: LoanPaymentCreateNestedManyWithoutPaymentSchedulesInput
  }

  export type PaymentScheduleUncheckedCreateWithoutLoanInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentScheduleCreateOrConnectWithoutLoanInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutLoanInput, PaymentScheduleUncheckedCreateWithoutLoanInput>
  }

  export type PaymentScheduleCreateManyLoanInputEnvelope = {
    data: Enumerable<PaymentScheduleCreateManyLoanInput>
    skipDuplicates?: boolean
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutLoanInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type LoantypeUpsertWithoutLoanInput = {
    update: XOR<LoantypeUpdateWithoutLoanInput, LoantypeUncheckedUpdateWithoutLoanInput>
    create: XOR<LoantypeCreateWithoutLoanInput, LoantypeUncheckedCreateWithoutLoanInput>
  }

  export type LoantypeUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoantypeUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekDuration?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    overdueRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutLoanInput = {
    update: XOR<EmployeeUpdateWithoutLoanInput, EmployeeUncheckedUpdateWithoutLoanInput>
    create: XOR<EmployeeCreateWithoutLoanInput, EmployeeUncheckedCreateWithoutLoanInput>
  }

  export type EmployeeUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    documents?: DocumentUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type ContractUpsertWithoutLoansInput = {
    update: XOR<ContractUpdateWithoutLoansInput, ContractUncheckedUpdateWithoutLoansInput>
    create: XOR<ContractCreateWithoutLoansInput, ContractUncheckedCreateWithoutLoansInput>
  }

  export type ContractUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: BorrowerUpdateOneRequiredWithoutContractInput
    employee?: EmployeeUpdateOneWithoutContractsInput
    documents?: DocumentUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutContractInput
  }

  export type PaymentScheduleUpsertWithWhereUniqueWithoutLoanInput = {
    where: PaymentScheduleWhereUniqueInput
    update: XOR<PaymentScheduleUpdateWithoutLoanInput, PaymentScheduleUncheckedUpdateWithoutLoanInput>
    create: XOR<PaymentScheduleCreateWithoutLoanInput, PaymentScheduleUncheckedCreateWithoutLoanInput>
  }

  export type PaymentScheduleUpdateWithWhereUniqueWithoutLoanInput = {
    where: PaymentScheduleWhereUniqueInput
    data: XOR<PaymentScheduleUpdateWithoutLoanInput, PaymentScheduleUncheckedUpdateWithoutLoanInput>
  }

  export type PaymentScheduleUpdateManyWithWhereWithoutLoanInput = {
    where: PaymentScheduleScalarWhereInput
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyWithoutPaymentScheduleInput>
  }

  export type PaymentScheduleScalarWhereInput = {
    AND?: Enumerable<PaymentScheduleScalarWhereInput>
    OR?: Enumerable<PaymentScheduleScalarWhereInput>
    NOT?: Enumerable<PaymentScheduleScalarWhereInput>
    id?: StringFilter | string
    numeration?: IntFilter | number
    amountToPay?: DecimalFilter | Decimal | number | string
    paidAmount?: DecimalFilter | Decimal | number | string
    status?: EnumPaymentStateFilter | PaymentState
    delayed?: BoolFilter | boolean
    dueDate?: DateTimeFilter | Date | string
    details?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    loanId?: StringFilter | string
  }

  export type PaymentScheduleCreateWithoutLoanPaymentsInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutPaymentScheduleInput
  }

  export type PaymentScheduleUncheckedCreateWithoutLoanPaymentsInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
  }

  export type PaymentScheduleCreateOrConnectWithoutLoanPaymentsInput = {
    where: PaymentScheduleWhereUniqueInput
    create: XOR<PaymentScheduleCreateWithoutLoanPaymentsInput, PaymentScheduleUncheckedCreateWithoutLoanPaymentsInput>
  }

  export type LoanCreateWithoutPaymentsInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loanType: LoantypeCreateNestedOneWithoutLoanInput
    employee: EmployeeCreateNestedOneWithoutLoanInput
    contract: ContractCreateNestedOneWithoutLoansInput
    paymentSchedule?: PaymentScheduleCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutPaymentsInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
    employeeId: string
    paymentSchedule?: PaymentScheduleUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutPaymentsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
  }

  export type EmployeeCreateWithoutLoanPaymentInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    phones?: PhoneCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    loan?: LoanCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLoanPaymentInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    phones?: PhoneUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    loan?: LoanUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLoanPaymentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLoanPaymentInput, EmployeeUncheckedCreateWithoutLoanPaymentInput>
  }

  export type PaymentScheduleUpsertWithWhereUniqueWithoutLoanPaymentsInput = {
    where: PaymentScheduleWhereUniqueInput
    update: XOR<PaymentScheduleUpdateWithoutLoanPaymentsInput, PaymentScheduleUncheckedUpdateWithoutLoanPaymentsInput>
    create: XOR<PaymentScheduleCreateWithoutLoanPaymentsInput, PaymentScheduleUncheckedCreateWithoutLoanPaymentsInput>
  }

  export type PaymentScheduleUpdateWithWhereUniqueWithoutLoanPaymentsInput = {
    where: PaymentScheduleWhereUniqueInput
    data: XOR<PaymentScheduleUpdateWithoutLoanPaymentsInput, PaymentScheduleUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type PaymentScheduleUpdateManyWithWhereWithoutLoanPaymentsInput = {
    where: PaymentScheduleScalarWhereInput
    data: XOR<PaymentScheduleUpdateManyMutationInput, PaymentScheduleUncheckedUpdateManyWithoutPaymentSchedulesInput>
  }

  export type LoanUpsertWithoutPaymentsInput = {
    update: XOR<LoanUpdateWithoutPaymentsInput, LoanUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LoanCreateWithoutPaymentsInput, LoanUncheckedCreateWithoutPaymentsInput>
  }

  export type LoanUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: LoantypeUpdateOneRequiredWithoutLoanInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanInput
    contract?: ContractUpdateOneRequiredWithoutLoansInput
    paymentSchedule?: PaymentScheduleUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    paymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutLoanInput
  }

  export type EmployeeUpsertWithoutLoanPaymentInput = {
    update: XOR<EmployeeUpdateWithoutLoanPaymentInput, EmployeeUncheckedUpdateWithoutLoanPaymentInput>
    create: XOR<EmployeeCreateWithoutLoanPaymentInput, EmployeeUncheckedCreateWithoutLoanPaymentInput>
  }

  export type EmployeeUpdateWithoutLoanPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    documents?: DocumentUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutLoanPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
  }

  export type LoanCreateWithoutPaymentScheduleInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: LoanPaymentCreateNestedManyWithoutLoanInput
    loanType: LoantypeCreateNestedOneWithoutLoanInput
    employee: EmployeeCreateNestedOneWithoutLoanInput
    contract: ContractCreateNestedOneWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutPaymentScheduleInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
    employeeId: string
    payments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutPaymentScheduleInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutPaymentScheduleInput, LoanUncheckedCreateWithoutPaymentScheduleInput>
  }

  export type LoanPaymentCreateWithoutPaymentSchedulesInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutPaymentsInput
    employee: EmployeeCreateNestedOneWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedCreateWithoutPaymentSchedulesInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
    employeeId: string
  }

  export type LoanPaymentCreateOrConnectWithoutPaymentSchedulesInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutPaymentSchedulesInput, LoanPaymentUncheckedCreateWithoutPaymentSchedulesInput>
  }

  export type LoanUpsertWithoutPaymentScheduleInput = {
    update: XOR<LoanUpdateWithoutPaymentScheduleInput, LoanUncheckedUpdateWithoutPaymentScheduleInput>
    create: XOR<LoanCreateWithoutPaymentScheduleInput, LoanUncheckedCreateWithoutPaymentScheduleInput>
  }

  export type LoanUpdateWithoutPaymentScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanInput
    loanType?: LoantypeUpdateOneRequiredWithoutLoanInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanInput
    contract?: ContractUpdateOneRequiredWithoutLoansInput
  }

  export type LoanUncheckedUpdateWithoutPaymentScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanInput
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutPaymentSchedulesInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutPaymentSchedulesInput, LoanPaymentUncheckedUpdateWithoutPaymentSchedulesInput>
    create: XOR<LoanPaymentCreateWithoutPaymentSchedulesInput, LoanPaymentUncheckedCreateWithoutPaymentSchedulesInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutPaymentSchedulesInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutPaymentSchedulesInput, LoanPaymentUncheckedUpdateWithoutPaymentSchedulesInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutPaymentSchedulesInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutLoanPaymentsInput>
  }

  export type LogCreateManySectionInput = {
    id?: string
    requestBody: string
    requestType: string
    deviceType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestBody?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyUserInput = {
    id?: string
    type: EmployeesTypes
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUpdateManyWithoutEmployeeInput
    documents?: DocumentUpdateManyWithoutEmployeeInput
    contracts?: ContractUpdateManyWithoutEmployeeInput
    loan?: LoanUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phones?: PhoneUncheckedUpdateManyWithoutEmployeeInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeInput
    loan?: LoanUncheckedUpdateManyWithoutEmployeeInput
    loanPayment?: LoanPaymentUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeesTypesFieldUpdateOperationsInput | EmployeesTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneCreateManyEmployeeInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
  }

  export type DocumentCreateManyEmployeeInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    contractId?: string | null
  }

  export type ContractCreateManyEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    borrowerId: string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateManyEmployeeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    loantypeId: string
  }

  export type LoanPaymentCreateManyEmployeeInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanId: string
  }

  export type PhoneUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Borrower?: BorrowerUpdateOneWithoutPhonesInput
    aval?: AvalUpdateOneWithoutPhonesInput
  }

  export type PhoneUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneUncheckedUpdateManyWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    Borrower?: BorrowerUpdateOneWithoutDocumentsInput
    aval?: AvalUpdateOneWithoutDocumentsInput
    Contract?: ContractUpdateOneWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: BorrowerUpdateOneRequiredWithoutContractInput
    documents?: DocumentUpdateManyWithoutContractInput
    loans?: LoanUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractInput
    loans?: LoanUncheckedUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateManyWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanInput
    loanType?: LoantypeUpdateOneRequiredWithoutLoanInput
    contract?: ContractUpdateOneRequiredWithoutLoansInput
    paymentSchedule?: PaymentScheduleUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    loantypeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentSchedules?: PaymentScheduleUpdateManyWithoutLoanPaymentsInput
    loan?: LoanUpdateOneRequiredWithoutPaymentsInput
  }

  export type LoanPaymentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneCreateManyAvalInput = {
    id?: string
    number: string
    borrowerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
  }

  export type DocumentCreateManyAvalInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type PhoneUpdateWithoutAvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Borrower?: BorrowerUpdateOneWithoutPhonesInput
    Employee?: EmployeeUpdateOneWithoutPhonesInput
  }

  export type PhoneUncheckedUpdateWithoutAvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutAvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    Borrower?: BorrowerUpdateOneWithoutDocumentsInput
    Employee?: EmployeeUpdateOneWithoutDocumentsInput
    Contract?: ContractUpdateOneWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateWithoutAvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneCreateManyBorrowerInput = {
    id?: string
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avalId?: string | null
    employeeId?: string | null
  }

  export type DocumentCreateManyBorrowerInput = {
    id?: string
    type: DocumentType
    avalId?: string | null
    contractId?: string | null
    employeeId?: string | null
  }

  export type ContractCreateManyBorrowerInput = {
    id?: string
    amount: Decimal | number | string
    createdAt?: Date | string
    dueDate: Date | string
    signDate: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type LocalCreateManyBorrowerInput = {
    id?: string
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneWithoutPhonesInput
    aval?: AvalUpdateOneWithoutPhonesInput
  }

  export type PhoneUncheckedUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    Employee?: EmployeeUpdateOneWithoutDocumentsInput
    aval?: AvalUpdateOneWithoutDocumentsInput
    Contract?: ContractUpdateOneWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutContractsInput
    documents?: DocumentUpdateManyWithoutContractInput
    loans?: LoanUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutContractInput
    loans?: LoanUncheckedUpdateManyWithoutContractInput
  }

  export type ContractUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    signDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LocalUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalUncheckedUpdateWithoutBorrowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalUncheckedUpdateManyWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanCreateManyLoanTypeInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId: string
    employeeId: string
  }

  export type LoanUpdateWithoutLoanTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanInput
    contract?: ContractUpdateOneRequiredWithoutLoansInput
    paymentSchedule?: PaymentScheduleUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateWithoutLoanTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutLoanInput
  }

  export type DocumentCreateManyContractInput = {
    id?: string
    type: DocumentType
    borrowerId?: string | null
    avalId?: string | null
    employeeId?: string | null
  }

  export type LoanCreateManyContractInput = {
    id?: string
    status: LoanState
    weeklyPaymentAmount: Decimal | number | string
    amountToPay?: Decimal | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loantypeId: string
    employeeId: string
  }

  export type DocumentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    Borrower?: BorrowerUpdateOneWithoutDocumentsInput
    Employee?: EmployeeUpdateOneWithoutDocumentsInput
    aval?: AvalUpdateOneWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    borrowerId?: NullableStringFieldUpdateOperationsInput | string | null
    avalId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoanUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: LoanPaymentUpdateManyWithoutLoanInput
    loanType?: LoantypeUpdateOneRequiredWithoutLoanInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanInput
    paymentSchedule?: PaymentScheduleUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    payments?: LoanPaymentUncheckedUpdateManyWithoutLoanInput
    paymentSchedule?: PaymentScheduleUncheckedUpdateManyWithoutLoanInput
  }

  export type LoanUncheckedUpdateManyWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLoanStateFieldUpdateOperationsInput | LoanState
    weeklyPaymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loantypeId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentCreateManyLoanInput = {
    id?: string
    amount: Decimal | number | string
    date: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type PaymentScheduleCreateManyLoanInput = {
    id?: string
    numeration: number
    amountToPay: Decimal | number | string
    paidAmount: Decimal | number | string
    status: PaymentState
    delayed?: boolean
    dueDate: Date | string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentSchedules?: PaymentScheduleUpdateManyWithoutLoanPaymentsInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentScheduleUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUpdateManyWithoutPaymentSchedulesInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutPaymentScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentScheduleUpdateWithoutLoanPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutPaymentScheduleInput
  }

  export type PaymentScheduleUncheckedUpdateWithoutLoanPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentScheduleUncheckedUpdateManyWithoutPaymentSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeration?: IntFieldUpdateOperationsInput | number
    amountToPay?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    status?: EnumPaymentStateFieldUpdateOperationsInput | PaymentState
    delayed?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentUpdateWithoutPaymentSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutPaymentsInput
    employee?: EmployeeUpdateOneRequiredWithoutLoanPaymentInput
  }

  export type LoanPaymentUncheckedUpdateWithoutPaymentSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}