# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ContractType {
  id: ID!
  name: String!
  monthDuration: Int!
  amount: Decimal!
  createdAt: DateTime!
  updatedAt: DateTime
}

"""An arbitrary-precision Decimal type"""
scalar Decimal

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type AvalCount {
  phones: Int!
  documents: Int!
}

type Aval {
  id: ID!
  phones: [Phone!]
  email: String!
  fullName: String!
  firstName: String!
  lastName: String!
  documents: [Document!]
  createdAt: DateTime!
  updatedAt: DateTime!
  _count: AvalCount!
}

type PaymentScheduleCount {
  loanPayments: Int!
}

type PaymentSchedule {
  id: ID!
  numeration: Int!
  amountToPay: Decimal!
  paidAmount: Decimal!
  status: PaymentState!
  delayed: Boolean!
  dueDate: DateTime!
  details: String
  createdAt: DateTime!
  updatedAt: DateTime!
  loan: Loan!
  loanId: String!
  loanPayments: [LoanPayment!]
  _count: PaymentScheduleCount!
}

enum PaymentState {
  PENDING
  PAID_OUT
  PARTIALLY_PAID
}

type LoanPaymentCount {
  paymentSchedules: Int!
}

type LoanPayment {
  id: ID!
  amount: Decimal!
  date: DateTime!
  comments: String
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentSchedules: [PaymentSchedule!]
  loan: Loan!
  loanId: String!
  employee: Employee!
  employeeId: String!
  _count: LoanPaymentCount!
}

type LoantypeCount {
  Loan: Int!
}

type Loantype {
  id: ID!
  name: String!
  weekDuration: Int!
  rate: Float!
  overdueRate: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  Loan: [Loan!]
  _count: LoantypeCount!
}

type LoanCount {
  payments: Int!
  paymentSchedule: Int!
}

type Loan {
  id: ID!
  status: LoanState!
  payments: [LoanPayment!]
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal!
  loanType: Loantype!
  createdAt: DateTime!
  employee: Employee!
  updatedAt: DateTime!
  contract: Contract!
  contractId: String!
  loantypeId: String!
  employeeId: String!
  paymentSchedule: [PaymentSchedule!]
  _count: LoanCount!
  totalPaidAmount: Float!
}

enum LoanState {
  REQUESTED
  IN_REVIEW
  APPROVED
  REJECTED
  PAID_OUT
  POSTPONED
}

type ContractCount {
  documents: Int!
  loans: Int!
}

type Contract {
  id: ID!
  amount: Decimal!
  borrower: Borrower!
  borrowerId: String!
  employee: Employee
  documents: [Document!]
  loans: [Loan!]
  createdAt: DateTime!
  dueDate: DateTime!
  signDate: DateTime!
  updatedAt: DateTime!
  employeeId: String!
  _count: ContractCount!
}

type Document {
  id: ID!
  type: DocumentType!
  Borrower: Borrower
  borrowerId: String
  Employee: Employee
  aval: Aval
  avalId: String
  Contract: Contract
  contractId: String
  employeeId: String
}

enum DocumentType {
  DNI
  NSS
  RFC
  SHOP_PHOTO
  BANC_ACCOUNT
  ADDRESS_PROFF
  CREDIT_BUREAU
  DRIVER_LICENCE
  JOB_APPLICATION
  CONTRACT_EVIDENCE
  LETTER_NO_CRIMINAL_RECORD
}

type Local {
  id: ID!
  name: String!
  address: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  borrower: Borrower!
  borrowerId: String!
}

type BorrowerCount {
  phones: Int!
  documents: Int!
  Contract: Int!
  Local: Int!
}

type Borrower {
  id: ID!
  name: String!
  address: String!
  email: String
  phones: [Phone!]
  documents: [Document!]
  createdAt: DateTime!
  updatedAt: DateTime!
  Contract: [Contract!]
  Local: [Local!]
  _count: BorrowerCount!
}

type Phone {
  id: ID!
  number: String!
  Borrower: Borrower
  borrowerId: String
  Employee: Employee
  createdAt: DateTime!
  updatedAt: DateTime!
  aval: Aval
  avalId: String
  employeeId: String
}

type EmployeeCount {
  phones: Int!
  documents: Int!
  contracts: Int!
  loan: Int!
  loanPayment: Int!
}

type Employee {
  id: ID!
  type: EmployeesTypes!
  phones: [Phone!]
  documents: [Document!]
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  contracts: [Contract!]
  loan: [Loan!]
  userId: String!
  loanPayment: [LoanPayment!]
  _count: EmployeeCount!
}

enum EmployeesTypes {
  EJECUTIVO_DE_ENLACE
}

type UserCount {
  Employee: Int!
}

type User {
  id: ID!
  email: String!
  fullName: String!
  firstName: String!
  lastName: String!
  password: String!
  lastLogin: DateTime
  profilePicture: String
  createdAt: DateTime!
  updatedAt: DateTime!
  Employee: [Employee!]
  _count: UserCount!
}

type SignInOutput {
  token: String!
  user: User!
}

type Query {
  contractTypes: [ContractType!]!
  borrowers(where: BorrowerWhereInput!): [Borrower!]!
  employees: [Employee!]!
  contracts: [Contract!]!
  loans(where: LoanWhereInput!): [Loan!]!
  loanTypes(where: LoantypeWhereInput!): [Loantype!]!
  loanPayments(where: LoanPaymentWhereInput!): [LoanPayment!]!
  paymentSchedulesWhere(where: PaymentScheduleWhereInput!): [PaymentSchedule!]!
  locals(where: LocalWhereInput!): [Local!]!
}

input BorrowerWhereInput {
  AND: [BorrowerWhereInput!]
  OR: [BorrowerWhereInput!]
  NOT: [BorrowerWhereInput!]
  id: StringFilter
  name: StringFilter
  address: StringFilter
  email: StringNullableFilter
  phones: PhoneListRelationFilter
  documents: DocumentListRelationFilter
  Contract: ContractListRelationFilter
  Local: LocalListRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input PhoneListRelationFilter {
  every: PhoneWhereInput
  some: PhoneWhereInput
  none: PhoneWhereInput
}

input PhoneWhereInput {
  AND: [PhoneWhereInput!]
  OR: [PhoneWhereInput!]
  NOT: [PhoneWhereInput!]
  id: StringFilter
  number: StringFilter
  Borrower: BorrowerRelationFilter
  aval: AvalRelationFilter
  avalId: StringNullableFilter
  employeeId: StringNullableFilter
}

input BorrowerRelationFilter {
  is: BorrowerWhereInput
  isNot: BorrowerWhereInput
}

input AvalRelationFilter {
  is: AvalWhereInput
  isNot: AvalWhereInput
}

input AvalWhereInput {
  AND: [AvalWhereInput!]
  OR: [AvalWhereInput!]
  NOT: [AvalWhereInput!]
  id: StringFilter
  phones: PhoneListRelationFilter
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  documents: DocumentListRelationFilter
}

input DocumentListRelationFilter {
  every: DocumentWhereInput
  some: DocumentWhereInput
  none: DocumentWhereInput
}

input DocumentWhereInput {
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
  id: StringFilter
  type: EnumDocumentTypeFilter
  Borrower: BorrowerRelationFilter
  borrowerId: StringNullableFilter
  Employee: EmployeeRelationFilter
  aval: AvalRelationFilter
  avalId: StringNullableFilter
  Contract: ContractRelationFilter
  contractId: StringNullableFilter
  employeeId: StringNullableFilter
}

input EnumDocumentTypeFilter {
  equals: DocumentType
  in: [DocumentType!]
  notIn: [DocumentType!]
  not: NestedEnumDocumentTypeFilter
}

input NestedEnumDocumentTypeFilter {
  equals: DocumentType
  in: [DocumentType!]
  notIn: [DocumentType!]
  not: NestedEnumDocumentTypeFilter
}

input EmployeeRelationFilter {
  is: EmployeeWhereInput
  isNot: EmployeeWhereInput
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
  id: StringFilter
  type: EnumEmployeesTypesFilter
  phones: PhoneListRelationFilter
  documents: DocumentListRelationFilter
  user: UserRelationFilter
  contracts: ContractListRelationFilter
  loan: LoanListRelationFilter
  userId: StringFilter
  loanPayment: LoanPaymentListRelationFilter
}

input EnumEmployeesTypesFilter {
  equals: EmployeesTypes
  in: [EmployeesTypes!]
  notIn: [EmployeesTypes!]
  not: NestedEnumEmployeesTypesFilter
}

input NestedEnumEmployeesTypesFilter {
  equals: EmployeesTypes
  in: [EmployeesTypes!]
  notIn: [EmployeesTypes!]
  not: NestedEnumEmployeesTypesFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  password: StringFilter
  Employee: EmployeeListRelationFilter
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  some: EmployeeWhereInput
  none: EmployeeWhereInput
}

input ContractListRelationFilter {
  every: ContractWhereInput
  some: ContractWhereInput
  none: ContractWhereInput
}

input ContractWhereInput {
  AND: [ContractWhereInput!]
  OR: [ContractWhereInput!]
  NOT: [ContractWhereInput!]
  id: StringFilter
  amount: DecimalFilter
  borrower: BorrowerRelationFilter
  borrowerId: StringFilter
  employee: EmployeeRelationFilter
  documents: DocumentListRelationFilter
  dueDate: DateTimeFilter
  signDate: DateTimeFilter
  employeeId: StringFilter
}

input DecimalFilter {
  equals: Decimal
  in: [Decimal!]
  notIn: [Decimal!]
  lt: Decimal
  lte: Decimal
  gt: Decimal
  gte: Decimal
  not: NestedDecimalFilter
}

input NestedDecimalFilter {
  equals: Decimal
  in: [Decimal!]
  notIn: [Decimal!]
  lt: Decimal
  lte: Decimal
  gt: Decimal
  gte: Decimal
  not: NestedDecimalFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input LoanListRelationFilter {
  every: LoanWhereInput
  some: LoanWhereInput
  none: LoanWhereInput
}

input LoanWhereInput {
  AND: [LoanWhereInput!]
  OR: [LoanWhereInput!]
  NOT: [LoanWhereInput!]
  id: StringFilter
  weeklyPaymentAmount: DecimalFilter
  amountToPay: DecimalFilter
  loanType: LoantypeRelationFilter
  employee: EmployeeRelationFilter
  contract: ContractRelationFilter
  contractId: StringFilter
  loantypeId: StringFilter
  employeeId: StringFilter
  paymentSchedule: PaymentScheduleListRelationFilter
}

input LoantypeRelationFilter {
  is: LoantypeWhereInput
  isNot: LoantypeWhereInput
}

input LoantypeWhereInput {
  AND: [LoantypeWhereInput!]
  OR: [LoantypeWhereInput!]
  NOT: [LoantypeWhereInput!]
  id: StringFilter
  name: StringFilter
  weekDuration: IntFilter
  rate: FloatFilter
  overdueRate: FloatFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  Loan: LoanListRelationFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input FloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input ContractRelationFilter {
  is: ContractWhereInput
  isNot: ContractWhereInput
}

input PaymentScheduleListRelationFilter {
  every: PaymentScheduleWhereInput
  some: PaymentScheduleWhereInput
  none: PaymentScheduleWhereInput
}

input PaymentScheduleWhereInput {
  AND: [PaymentScheduleWhereInput!]
  OR: [PaymentScheduleWhereInput!]
  NOT: [PaymentScheduleWhereInput!]
  id: StringFilter
  numeration: IntFilter
  amountToPay: DecimalFilter
  paidAmount: DecimalFilter
  delayed: BoolFilter
  dueDate: DateTimeFilter
  details: StringNullableFilter
  loan: LoanRelationFilter
  loanId: StringFilter
  loanPayments: LoanPaymentListRelationFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input LoanRelationFilter {
  is: LoanWhereInput
  isNot: LoanWhereInput
}

input LoanPaymentListRelationFilter {
  every: LoanPaymentWhereInput
  some: LoanPaymentWhereInput
  none: LoanPaymentWhereInput
}

input LoanPaymentWhereInput {
  AND: [LoanPaymentWhereInput!]
  OR: [LoanPaymentWhereInput!]
  NOT: [LoanPaymentWhereInput!]
  id: StringFilter
  amount: DecimalFilter
  date: DateTimeFilter
  comments: StringNullableFilter
  paymentSchedules: PaymentScheduleListRelationFilter
  loan: LoanRelationFilter
  loanId: StringFilter
  employee: EmployeeRelationFilter
  employeeId: StringFilter
}

input LocalListRelationFilter {
  every: LocalWhereInput
  some: LocalWhereInput
  none: LocalWhereInput
}

input LocalWhereInput {
  AND: [LocalWhereInput!]
  OR: [LocalWhereInput!]
  NOT: [LocalWhereInput!]
  id: StringFilter
  name: StringFilter
  address: StringFilter
  borrower: BorrowerRelationFilter
  borrowerId: StringFilter
}

type Mutation {
  createContractType(input: ContractTypeCreateInput!): ContractType!
  signUp(input: UserCreateInput!): User!
  signIn(input: SignInInput!): SignInOutput!
  createBorrower(input: BorrowerCreateInput!): Borrower!
  createEmployee(input: EmployeeCreateInput!): Employee!
  createContract(input: ContractCreateInput!): Contract!
  createLoan(input: CustomCreateLoanInput!): Loan!
  createLoanPayment(input: LoanPaymentCreateInput!): LoanPayment!
  setLoanPayment(input: LoanPaymentUpdateInput!): Loan!
  createLoanType(input: LoantypeCreateInput!): Loantype!
  createPhone(input: PhoneCreateInput!): Phone!
  createLocal(input: LocalCreateInput!): Local!
}

input ContractTypeCreateInput {
  name: String!
  monthDuration: Int!
  amount: Decimal!
}

input UserCreateInput {
  id: String
  email: EmailAddress!
  firstName: String!
  lastName: String!
  password: String!
  Employee: EmployeeCreateNestedManyWithoutUserInput
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

input EmployeeCreateNestedManyWithoutUserInput {
  create: [EmployeeCreateWithoutUserInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutUserInput!]
  createMany: EmployeeCreateManyUserInputEnvelope
  connect: [EmployeeWhereUniqueInput!]
}

input EmployeeCreateWithoutUserInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  documents: DocumentCreateNestedManyWithoutEmployeeInput
  contracts: ContractCreateNestedManyWithoutEmployeeInput
  loan: LoanCreateNestedManyWithoutEmployeeInput
  loanPayment: LoanPaymentCreateNestedManyWithoutEmployeeInput
}

input PhoneCreateNestedManyWithoutEmployeeInput {
  create: [PhoneCreateWithoutEmployeeInput!]
  connectOrCreate: [PhoneCreateOrConnectWithoutEmployeeInput!]
  createMany: PhoneCreateManyEmployeeInputEnvelope
  connect: [PhoneWhereUniqueInput!]
}

input PhoneCreateWithoutEmployeeInput {
  number: String!
  Borrower: BorrowerCreateNestedOneWithoutPhonesInput
  aval: AvalCreateNestedOneWithoutPhonesInput
}

input BorrowerCreateNestedOneWithoutPhonesInput {
  create: BorrowerCreateWithoutPhonesInput
  connectOrCreate: BorrowerCreateOrConnectWithoutPhonesInput
  connect: BorrowerWhereUniqueInput
}

input BorrowerCreateWithoutPhonesInput {
  name: String!
  address: String!
  email: EmailAddress
  documents: DocumentCreateNestedManyWithoutBorrowerInput
  Contract: ContractCreateNestedManyWithoutBorrowerInput
  Local: LocalCreateNestedManyWithoutBorrowerInput
}

input DocumentCreateNestedManyWithoutBorrowerInput {
  create: [DocumentCreateWithoutBorrowerInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutBorrowerInput!]
  createMany: DocumentCreateManyBorrowerInputEnvelope
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateWithoutBorrowerInput {
  id: String
  type: DocumentType!
  Employee: EmployeeCreateNestedOneWithoutDocumentsInput
  aval: AvalCreateNestedOneWithoutDocumentsInput
  Contract: ContractCreateNestedOneWithoutDocumentsInput
}

input EmployeeCreateNestedOneWithoutDocumentsInput {
  create: EmployeeCreateWithoutDocumentsInput
  connectOrCreate: EmployeeCreateOrConnectWithoutDocumentsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutDocumentsInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  user: UserCreateNestedOneWithoutEmployeeInput!
  contracts: ContractCreateNestedManyWithoutEmployeeInput
  loan: LoanCreateNestedManyWithoutEmployeeInput
  loanPayment: LoanPaymentCreateNestedManyWithoutEmployeeInput
}

input UserCreateNestedOneWithoutEmployeeInput {
  create: UserCreateWithoutEmployeeInput
  connectOrCreate: UserCreateOrConnectWithoutEmployeeInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutEmployeeInput {
  id: String
  email: EmailAddress!
  firstName: String!
  lastName: String!
  password: String!
}

input UserCreateOrConnectWithoutEmployeeInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutEmployeeInput!
}

input UserWhereUniqueInput {
  id: String
  email: EmailAddress
}

input ContractCreateNestedManyWithoutEmployeeInput {
  create: [ContractCreateWithoutEmployeeInput!]
  connectOrCreate: [ContractCreateOrConnectWithoutEmployeeInput!]
  createMany: ContractCreateManyEmployeeInputEnvelope
  connect: [ContractWhereUniqueInput!]
}

input ContractCreateWithoutEmployeeInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  borrower: BorrowerCreateNestedOneWithoutContractInput!
  documents: DocumentCreateNestedManyWithoutContractInput
}

input BorrowerCreateNestedOneWithoutContractInput {
  create: BorrowerCreateWithoutContractInput
  connectOrCreate: BorrowerCreateOrConnectWithoutContractInput
  connect: BorrowerWhereUniqueInput
}

input BorrowerCreateWithoutContractInput {
  name: String!
  address: String!
  email: EmailAddress
  phones: PhoneCreateNestedManyWithoutBorrowerInput
  documents: DocumentCreateNestedManyWithoutBorrowerInput
  Local: LocalCreateNestedManyWithoutBorrowerInput
}

input PhoneCreateNestedManyWithoutBorrowerInput {
  create: [PhoneCreateWithoutBorrowerInput!]
  connectOrCreate: [PhoneCreateOrConnectWithoutBorrowerInput!]
  createMany: PhoneCreateManyBorrowerInputEnvelope
  connect: [PhoneWhereUniqueInput!]
}

input PhoneCreateWithoutBorrowerInput {
  number: String!
  aval: AvalCreateNestedOneWithoutPhonesInput
}

input AvalCreateNestedOneWithoutPhonesInput {
  create: AvalCreateWithoutPhonesInput
  connectOrCreate: AvalCreateOrConnectWithoutPhonesInput
  connect: AvalWhereUniqueInput
}

input AvalCreateWithoutPhonesInput {
  id: String
  email: EmailAddress!
  firstName: String!
  lastName: String!
  documents: DocumentCreateNestedManyWithoutAvalInput
}

input DocumentCreateNestedManyWithoutAvalInput {
  create: [DocumentCreateWithoutAvalInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutAvalInput!]
  createMany: DocumentCreateManyAvalInputEnvelope
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateWithoutAvalInput {
  id: String
  type: DocumentType!
  Borrower: BorrowerCreateNestedOneWithoutDocumentsInput
  Employee: EmployeeCreateNestedOneWithoutDocumentsInput
  Contract: ContractCreateNestedOneWithoutDocumentsInput
}

input BorrowerCreateNestedOneWithoutDocumentsInput {
  create: BorrowerCreateWithoutDocumentsInput
  connectOrCreate: BorrowerCreateOrConnectWithoutDocumentsInput
  connect: BorrowerWhereUniqueInput
}

input BorrowerCreateWithoutDocumentsInput {
  name: String!
  address: String!
  email: EmailAddress
  phones: PhoneCreateNestedManyWithoutBorrowerInput
  Contract: ContractCreateNestedManyWithoutBorrowerInput
  Local: LocalCreateNestedManyWithoutBorrowerInput
}

input ContractCreateNestedManyWithoutBorrowerInput {
  create: [ContractCreateWithoutBorrowerInput!]
  connectOrCreate: [ContractCreateOrConnectWithoutBorrowerInput!]
  createMany: ContractCreateManyBorrowerInputEnvelope
  connect: [ContractWhereUniqueInput!]
}

input ContractCreateWithoutBorrowerInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  employee: EmployeeCreateNestedOneWithoutContractsInput
  documents: DocumentCreateNestedManyWithoutContractInput
}

input EmployeeCreateNestedOneWithoutContractsInput {
  create: EmployeeCreateWithoutContractsInput
  connectOrCreate: EmployeeCreateOrConnectWithoutContractsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutContractsInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  documents: DocumentCreateNestedManyWithoutEmployeeInput
  user: UserCreateNestedOneWithoutEmployeeInput!
  loan: LoanCreateNestedManyWithoutEmployeeInput
  loanPayment: LoanPaymentCreateNestedManyWithoutEmployeeInput
}

input DocumentCreateNestedManyWithoutEmployeeInput {
  create: [DocumentCreateWithoutEmployeeInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutEmployeeInput!]
  createMany: DocumentCreateManyEmployeeInputEnvelope
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateWithoutEmployeeInput {
  id: String
  type: DocumentType!
  Borrower: BorrowerCreateNestedOneWithoutDocumentsInput
  aval: AvalCreateNestedOneWithoutDocumentsInput
  Contract: ContractCreateNestedOneWithoutDocumentsInput
}

input AvalCreateNestedOneWithoutDocumentsInput {
  create: AvalCreateWithoutDocumentsInput
  connectOrCreate: AvalCreateOrConnectWithoutDocumentsInput
  connect: AvalWhereUniqueInput
}

input AvalCreateWithoutDocumentsInput {
  id: String
  email: EmailAddress!
  firstName: String!
  lastName: String!
  phones: PhoneCreateNestedManyWithoutAvalInput
}

input PhoneCreateNestedManyWithoutAvalInput {
  create: [PhoneCreateWithoutAvalInput!]
  connectOrCreate: [PhoneCreateOrConnectWithoutAvalInput!]
  createMany: PhoneCreateManyAvalInputEnvelope
  connect: [PhoneWhereUniqueInput!]
}

input PhoneCreateWithoutAvalInput {
  number: String!
  Borrower: BorrowerCreateNestedOneWithoutPhonesInput
}

input PhoneCreateOrConnectWithoutAvalInput {
  where: PhoneWhereUniqueInput!
  create: PhoneCreateWithoutAvalInput!
}

input PhoneWhereUniqueInput {
  id: String
  number: String
}

input PhoneCreateManyAvalInputEnvelope {
  data: [PhoneCreateManyAvalInput!]!
  skipDuplicates: Boolean
}

input PhoneCreateManyAvalInput {
  number: String!
  employeeId: String
}

input AvalCreateOrConnectWithoutDocumentsInput {
  where: AvalWhereUniqueInput!
  create: AvalCreateWithoutDocumentsInput!
}

input AvalWhereUniqueInput {
  id: String
  email: EmailAddress
}

input ContractCreateNestedOneWithoutDocumentsInput {
  create: ContractCreateWithoutDocumentsInput
  connectOrCreate: ContractCreateOrConnectWithoutDocumentsInput
  connect: ContractWhereUniqueInput
}

input ContractCreateWithoutDocumentsInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  borrower: BorrowerCreateNestedOneWithoutContractInput!
  employee: EmployeeCreateNestedOneWithoutContractsInput
}

input ContractCreateOrConnectWithoutDocumentsInput {
  where: ContractWhereUniqueInput!
  create: ContractCreateWithoutDocumentsInput!
}

input ContractWhereUniqueInput {
  id: String
}

input DocumentCreateOrConnectWithoutEmployeeInput {
  where: DocumentWhereUniqueInput!
  create: DocumentCreateWithoutEmployeeInput!
}

input DocumentWhereUniqueInput {
  id: String
}

input DocumentCreateManyEmployeeInputEnvelope {
  data: [DocumentCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input DocumentCreateManyEmployeeInput {
  id: String
  type: DocumentType!
  borrowerId: String
  avalId: String
  contractId: String
}

input LoanCreateNestedManyWithoutEmployeeInput {
  create: [LoanCreateWithoutEmployeeInput!]
  connectOrCreate: [LoanCreateOrConnectWithoutEmployeeInput!]
  createMany: LoanCreateManyEmployeeInputEnvelope
  connect: [LoanWhereUniqueInput!]
}

input LoanCreateWithoutEmployeeInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  loanType: LoantypeCreateNestedOneWithoutLoanInput!
  contract: ContractCreateNestedOneWithoutLoansInput!
  paymentSchedule: PaymentScheduleCreateNestedManyWithoutLoanInput
}

input LoantypeCreateNestedOneWithoutLoanInput {
  create: LoantypeCreateWithoutLoanInput
  connectOrCreate: LoantypeCreateOrConnectWithoutLoanInput
  connect: LoantypeWhereUniqueInput
}

input LoantypeCreateWithoutLoanInput {
  id: String
  name: String!
  weekDuration: Int!
  rate: Float!
  overdueRate: Float!
  createdAt: DateTime
  updatedAt: DateTime
}

input LoantypeCreateOrConnectWithoutLoanInput {
  where: LoantypeWhereUniqueInput!
  create: LoantypeCreateWithoutLoanInput!
}

input LoantypeWhereUniqueInput {
  id: String
}

input ContractCreateNestedOneWithoutLoansInput {
  create: ContractCreateWithoutLoansInput
  connectOrCreate: ContractCreateOrConnectWithoutLoansInput
  connect: ContractWhereUniqueInput
}

input ContractCreateWithoutLoansInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  borrower: BorrowerCreateNestedOneWithoutContractInput!
  employee: EmployeeCreateNestedOneWithoutContractsInput
  documents: DocumentCreateNestedManyWithoutContractInput
}

input DocumentCreateNestedManyWithoutContractInput {
  create: [DocumentCreateWithoutContractInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutContractInput!]
  createMany: DocumentCreateManyContractInputEnvelope
  connect: [DocumentWhereUniqueInput!]
}

input DocumentCreateWithoutContractInput {
  id: String
  type: DocumentType!
  Borrower: BorrowerCreateNestedOneWithoutDocumentsInput
  Employee: EmployeeCreateNestedOneWithoutDocumentsInput
  aval: AvalCreateNestedOneWithoutDocumentsInput
}

input DocumentCreateOrConnectWithoutContractInput {
  where: DocumentWhereUniqueInput!
  create: DocumentCreateWithoutContractInput!
}

input DocumentCreateManyContractInputEnvelope {
  data: [DocumentCreateManyContractInput!]!
  skipDuplicates: Boolean
}

input DocumentCreateManyContractInput {
  id: String
  type: DocumentType!
  borrowerId: String
  avalId: String
  employeeId: String
}

input ContractCreateOrConnectWithoutLoansInput {
  where: ContractWhereUniqueInput!
  create: ContractCreateWithoutLoansInput!
}

input PaymentScheduleCreateNestedManyWithoutLoanInput {
  create: [PaymentScheduleCreateWithoutLoanInput!]
  connectOrCreate: [PaymentScheduleCreateOrConnectWithoutLoanInput!]
  createMany: PaymentScheduleCreateManyLoanInputEnvelope
  connect: [PaymentScheduleWhereUniqueInput!]
}

input PaymentScheduleCreateWithoutLoanInput {
  numeration: Int!
  amountToPay: Decimal!
  paidAmount: Decimal!
  delayed: Boolean
  dueDate: DateTime!
  details: String
  loanPayments: LoanPaymentCreateNestedManyWithoutPaymentSchedulesInput
}

input LoanPaymentCreateNestedManyWithoutPaymentSchedulesInput {
  create: [LoanPaymentCreateWithoutPaymentSchedulesInput!]
  connectOrCreate: [LoanPaymentCreateOrConnectWithoutPaymentSchedulesInput!]
  connect: [LoanPaymentWhereUniqueInput!]
}

input LoanPaymentCreateWithoutPaymentSchedulesInput {
  id: String
  amount: Decimal!
  date: DateTime!
  comments: String
  loan: LoanCreateNestedOneWithoutPaymentsInput!
  employee: EmployeeCreateNestedOneWithoutLoanPaymentInput!
}

input LoanCreateNestedOneWithoutPaymentsInput {
  create: LoanCreateWithoutPaymentsInput
  connectOrCreate: LoanCreateOrConnectWithoutPaymentsInput
  connect: LoanWhereUniqueInput
}

input LoanCreateWithoutPaymentsInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  loanType: LoantypeCreateNestedOneWithoutLoanInput!
  employee: EmployeeCreateNestedOneWithoutLoanInput!
  contract: ContractCreateNestedOneWithoutLoansInput!
  paymentSchedule: PaymentScheduleCreateNestedManyWithoutLoanInput
}

input EmployeeCreateNestedOneWithoutLoanInput {
  create: EmployeeCreateWithoutLoanInput
  connectOrCreate: EmployeeCreateOrConnectWithoutLoanInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutLoanInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  documents: DocumentCreateNestedManyWithoutEmployeeInput
  user: UserCreateNestedOneWithoutEmployeeInput!
  contracts: ContractCreateNestedManyWithoutEmployeeInput
  loanPayment: LoanPaymentCreateNestedManyWithoutEmployeeInput
}

input LoanPaymentCreateNestedManyWithoutEmployeeInput {
  create: [LoanPaymentCreateWithoutEmployeeInput!]
  connectOrCreate: [LoanPaymentCreateOrConnectWithoutEmployeeInput!]
  createMany: LoanPaymentCreateManyEmployeeInputEnvelope
  connect: [LoanPaymentWhereUniqueInput!]
}

input LoanPaymentCreateWithoutEmployeeInput {
  id: String
  amount: Decimal!
  date: DateTime!
  comments: String
  paymentSchedules: PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput
  loan: LoanCreateNestedOneWithoutPaymentsInput!
}

input PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput {
  create: [PaymentScheduleCreateWithoutLoanPaymentsInput!]
  connectOrCreate: [PaymentScheduleCreateOrConnectWithoutLoanPaymentsInput!]
  connect: [PaymentScheduleWhereUniqueInput!]
}

input PaymentScheduleCreateWithoutLoanPaymentsInput {
  numeration: Int!
  amountToPay: Decimal!
  paidAmount: Decimal!
  delayed: Boolean
  dueDate: DateTime!
  details: String
  loan: LoanCreateNestedOneWithoutPaymentScheduleInput!
}

input LoanCreateNestedOneWithoutPaymentScheduleInput {
  create: LoanCreateWithoutPaymentScheduleInput
  connectOrCreate: LoanCreateOrConnectWithoutPaymentScheduleInput
  connect: LoanWhereUniqueInput
}

input LoanCreateWithoutPaymentScheduleInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  loanType: LoantypeCreateNestedOneWithoutLoanInput!
  employee: EmployeeCreateNestedOneWithoutLoanInput!
  contract: ContractCreateNestedOneWithoutLoansInput!
}

input LoanCreateOrConnectWithoutPaymentScheduleInput {
  where: LoanWhereUniqueInput!
  create: LoanCreateWithoutPaymentScheduleInput!
}

input LoanWhereUniqueInput {
  id: String
}

input PaymentScheduleCreateOrConnectWithoutLoanPaymentsInput {
  where: PaymentScheduleWhereUniqueInput!
  create: PaymentScheduleCreateWithoutLoanPaymentsInput!
}

input PaymentScheduleWhereUniqueInput {
  id: String
}

input LoanPaymentCreateOrConnectWithoutEmployeeInput {
  where: LoanPaymentWhereUniqueInput!
  create: LoanPaymentCreateWithoutEmployeeInput!
}

input LoanPaymentWhereUniqueInput {
  id: String
}

input LoanPaymentCreateManyEmployeeInputEnvelope {
  data: [LoanPaymentCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input LoanPaymentCreateManyEmployeeInput {
  id: String
  amount: Decimal!
  date: DateTime!
  comments: String
  loanId: String!
}

input EmployeeCreateOrConnectWithoutLoanInput {
  where: EmployeeWhereUniqueInput!
  create: EmployeeCreateWithoutLoanInput!
}

input EmployeeWhereUniqueInput {
  id: String
  userId: String
}

input LoanCreateOrConnectWithoutPaymentsInput {
  where: LoanWhereUniqueInput!
  create: LoanCreateWithoutPaymentsInput!
}

input EmployeeCreateNestedOneWithoutLoanPaymentInput {
  create: EmployeeCreateWithoutLoanPaymentInput
  connectOrCreate: EmployeeCreateOrConnectWithoutLoanPaymentInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutLoanPaymentInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  documents: DocumentCreateNestedManyWithoutEmployeeInput
  user: UserCreateNestedOneWithoutEmployeeInput!
  contracts: ContractCreateNestedManyWithoutEmployeeInput
  loan: LoanCreateNestedManyWithoutEmployeeInput
}

input EmployeeCreateOrConnectWithoutLoanPaymentInput {
  where: EmployeeWhereUniqueInput!
  create: EmployeeCreateWithoutLoanPaymentInput!
}

input LoanPaymentCreateOrConnectWithoutPaymentSchedulesInput {
  where: LoanPaymentWhereUniqueInput!
  create: LoanPaymentCreateWithoutPaymentSchedulesInput!
}

input PaymentScheduleCreateOrConnectWithoutLoanInput {
  where: PaymentScheduleWhereUniqueInput!
  create: PaymentScheduleCreateWithoutLoanInput!
}

input PaymentScheduleCreateManyLoanInputEnvelope {
  data: [PaymentScheduleCreateManyLoanInput!]!
  skipDuplicates: Boolean
}

input PaymentScheduleCreateManyLoanInput {
  numeration: Int!
  amountToPay: Decimal!
  paidAmount: Decimal!
  delayed: Boolean
  dueDate: DateTime!
  details: String
}

input LoanCreateOrConnectWithoutEmployeeInput {
  where: LoanWhereUniqueInput!
  create: LoanCreateWithoutEmployeeInput!
}

input LoanCreateManyEmployeeInputEnvelope {
  data: [LoanCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input LoanCreateManyEmployeeInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  contractId: String!
  loantypeId: String!
}

input EmployeeCreateOrConnectWithoutContractsInput {
  where: EmployeeWhereUniqueInput!
  create: EmployeeCreateWithoutContractsInput!
}

input ContractCreateOrConnectWithoutBorrowerInput {
  where: ContractWhereUniqueInput!
  create: ContractCreateWithoutBorrowerInput!
}

input ContractCreateManyBorrowerInputEnvelope {
  data: [ContractCreateManyBorrowerInput!]!
  skipDuplicates: Boolean
}

input ContractCreateManyBorrowerInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  employeeId: String!
}

input LocalCreateNestedManyWithoutBorrowerInput {
  create: [LocalCreateWithoutBorrowerInput!]
  connectOrCreate: [LocalCreateOrConnectWithoutBorrowerInput!]
  createMany: LocalCreateManyBorrowerInputEnvelope
  connect: [LocalWhereUniqueInput!]
}

input LocalCreateWithoutBorrowerInput {
  name: String!
  address: String!
}

input LocalCreateOrConnectWithoutBorrowerInput {
  where: LocalWhereUniqueInput!
  create: LocalCreateWithoutBorrowerInput!
}

input LocalWhereUniqueInput {
  id: String
}

input LocalCreateManyBorrowerInputEnvelope {
  data: [LocalCreateManyBorrowerInput!]!
  skipDuplicates: Boolean
}

input LocalCreateManyBorrowerInput {
  name: String!
  address: String!
}

input BorrowerCreateOrConnectWithoutDocumentsInput {
  where: BorrowerWhereUniqueInput!
  create: BorrowerCreateWithoutDocumentsInput!
}

input BorrowerWhereUniqueInput {
  id: String
  email: EmailAddress
}

input DocumentCreateOrConnectWithoutAvalInput {
  where: DocumentWhereUniqueInput!
  create: DocumentCreateWithoutAvalInput!
}

input DocumentCreateManyAvalInputEnvelope {
  data: [DocumentCreateManyAvalInput!]!
  skipDuplicates: Boolean
}

input DocumentCreateManyAvalInput {
  id: String
  type: DocumentType!
  borrowerId: String
  contractId: String
  employeeId: String
}

input AvalCreateOrConnectWithoutPhonesInput {
  where: AvalWhereUniqueInput!
  create: AvalCreateWithoutPhonesInput!
}

input PhoneCreateOrConnectWithoutBorrowerInput {
  where: PhoneWhereUniqueInput!
  create: PhoneCreateWithoutBorrowerInput!
}

input PhoneCreateManyBorrowerInputEnvelope {
  data: [PhoneCreateManyBorrowerInput!]!
  skipDuplicates: Boolean
}

input PhoneCreateManyBorrowerInput {
  number: String!
  avalId: String
  employeeId: String
}

input BorrowerCreateOrConnectWithoutContractInput {
  where: BorrowerWhereUniqueInput!
  create: BorrowerCreateWithoutContractInput!
}

input ContractCreateOrConnectWithoutEmployeeInput {
  where: ContractWhereUniqueInput!
  create: ContractCreateWithoutEmployeeInput!
}

input ContractCreateManyEmployeeInputEnvelope {
  data: [ContractCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input ContractCreateManyEmployeeInput {
  amount: Decimal!
  borrowerId: String!
  dueDate: DateTime!
  signDate: DateTime!
}

input EmployeeCreateOrConnectWithoutDocumentsInput {
  where: EmployeeWhereUniqueInput!
  create: EmployeeCreateWithoutDocumentsInput!
}

input DocumentCreateOrConnectWithoutBorrowerInput {
  where: DocumentWhereUniqueInput!
  create: DocumentCreateWithoutBorrowerInput!
}

input DocumentCreateManyBorrowerInputEnvelope {
  data: [DocumentCreateManyBorrowerInput!]!
  skipDuplicates: Boolean
}

input DocumentCreateManyBorrowerInput {
  id: String
  type: DocumentType!
  avalId: String
  contractId: String
  employeeId: String
}

input BorrowerCreateOrConnectWithoutPhonesInput {
  where: BorrowerWhereUniqueInput!
  create: BorrowerCreateWithoutPhonesInput!
}

input PhoneCreateOrConnectWithoutEmployeeInput {
  where: PhoneWhereUniqueInput!
  create: PhoneCreateWithoutEmployeeInput!
}

input PhoneCreateManyEmployeeInputEnvelope {
  data: [PhoneCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input PhoneCreateManyEmployeeInput {
  number: String!
  avalId: String
}

input EmployeeCreateOrConnectWithoutUserInput {
  where: EmployeeWhereUniqueInput!
  create: EmployeeCreateWithoutUserInput!
}

input EmployeeCreateManyUserInputEnvelope {
  data: [EmployeeCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input EmployeeCreateManyUserInput {
  type: EmployeesTypes!
}

input SignInInput {
  email: String!
  password: String!
}

input BorrowerCreateInput {
  name: String!
  address: String!
  email: EmailAddress
  phones: PhoneCreateNestedManyWithoutBorrowerInput
  documents: DocumentCreateNestedManyWithoutBorrowerInput
  Contract: ContractCreateNestedManyWithoutBorrowerInput
  Local: LocalCreateNestedManyWithoutBorrowerInput
}

input EmployeeCreateInput {
  type: EmployeesTypes!
  phones: PhoneCreateNestedManyWithoutEmployeeInput
  documents: DocumentCreateNestedManyWithoutEmployeeInput
  user: UserCreateNestedOneWithoutEmployeeInput!
  contracts: ContractCreateNestedManyWithoutEmployeeInput
  loan: LoanCreateNestedManyWithoutEmployeeInput
  loanPayment: LoanPaymentCreateNestedManyWithoutEmployeeInput
}

input ContractCreateInput {
  amount: Decimal!
  dueDate: DateTime!
  signDate: DateTime!
  borrower: BorrowerCreateNestedOneWithoutContractInput!
  employee: EmployeeCreateNestedOneWithoutContractsInput
  documents: DocumentCreateNestedManyWithoutContractInput
}

input CustomCreateLoanInput {
  amountToPay: Decimal
  loanType: LoantypeCreateNestedOneWithoutLoanInput!
  employee: EmployeeCreateNestedOneWithoutLoanInput!
  contract: ContractCreateNestedOneWithoutLoansInput!
  paymentSchedule: PaymentScheduleCreateNestedManyWithoutLoanInput
  firstPaymentDate: Date!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

input LoanPaymentCreateInput {
  id: String
  amount: Decimal!
  date: DateTime!
  comments: String
  paymentSchedules: PaymentScheduleCreateNestedManyWithoutLoanPaymentsInput
  loan: LoanCreateNestedOneWithoutPaymentsInput!
  employee: EmployeeCreateNestedOneWithoutLoanPaymentInput!
}

input LoanPaymentUpdateInput {
  amount: Decimal!
  paidDate: DateTime!
  details: NullableStringFieldUpdateOperationsInput
  employeeId: String!
  loanId: String!
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input LoantypeCreateInput {
  id: String
  name: String!
  weekDuration: Int!
  rate: Float!
  overdueRate: Float!
  createdAt: DateTime
  updatedAt: DateTime
  Loan: LoanCreateNestedManyWithoutLoanTypeInput
}

input LoanCreateNestedManyWithoutLoanTypeInput {
  create: [LoanCreateWithoutLoanTypeInput!]
  connectOrCreate: [LoanCreateOrConnectWithoutLoanTypeInput!]
  createMany: LoanCreateManyLoanTypeInputEnvelope
  connect: [LoanWhereUniqueInput!]
}

input LoanCreateWithoutLoanTypeInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  employee: EmployeeCreateNestedOneWithoutLoanInput!
  contract: ContractCreateNestedOneWithoutLoansInput!
  paymentSchedule: PaymentScheduleCreateNestedManyWithoutLoanInput
}

input LoanCreateOrConnectWithoutLoanTypeInput {
  where: LoanWhereUniqueInput!
  create: LoanCreateWithoutLoanTypeInput!
}

input LoanCreateManyLoanTypeInputEnvelope {
  data: [LoanCreateManyLoanTypeInput!]!
  skipDuplicates: Boolean
}

input LoanCreateManyLoanTypeInput {
  id: String
  weeklyPaymentAmount: Decimal!
  amountToPay: Decimal
  contractId: String!
  employeeId: String!
}

input PhoneCreateInput {
  number: String!
  Borrower: BorrowerCreateNestedOneWithoutPhonesInput
  aval: AvalCreateNestedOneWithoutPhonesInput
}

input LocalCreateInput {
  name: String!
  address: String!
  borrower: BorrowerCreateNestedOneWithoutLocalInput!
}

input BorrowerCreateNestedOneWithoutLocalInput {
  create: BorrowerCreateWithoutLocalInput
  connectOrCreate: BorrowerCreateOrConnectWithoutLocalInput
  connect: BorrowerWhereUniqueInput
}

input BorrowerCreateWithoutLocalInput {
  name: String!
  address: String!
  email: EmailAddress
  phones: PhoneCreateNestedManyWithoutBorrowerInput
  documents: DocumentCreateNestedManyWithoutBorrowerInput
  Contract: ContractCreateNestedManyWithoutBorrowerInput
}

input BorrowerCreateOrConnectWithoutLocalInput {
  where: BorrowerWhereUniqueInput!
  create: BorrowerCreateWithoutLocalInput!
}
